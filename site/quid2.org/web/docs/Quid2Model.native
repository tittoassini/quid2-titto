Pandoc (Meta {unMeta = fromList [("author",MetaList [MetaInlines [Str "Pasqualino",Space,Str "`Titto'",Space,Str "Assini",Space,Str "(tittoassini@gmail.com)"]]),("date",MetaInlines [Str "22",Superscript [Str "nd"],Space,Str "of",Space,Str "November",Space,Str "2015"]),("title",MetaInlines [Str "Quid2",Space,Str "Model",Space,Str "(First",Space,Str "Draft)"])]}) [Header 1 ("quid2-model",[],[]) [Str "Quid2",Space,Str "Model"],Para [Str "Quid2",Space,Str "Model",Space,Str "is",Space,Str "a",Space,Str "simple",Space,Str "data",Space,Str "declaration",Space,Str "language."],Para [Str "It",Space,Str "is",Space,Str "self-described",Space,Str "by",Space,Str "the",Space,Str "following",Space,Str "model:"],CodeBlock ("",["haskell"],[]) "-- A type expression\ndata Type ref = TypeCon ref\n\n               -- | Type application\n               | TypeApp (Type ref) (Type ref)\n\n-- Simple algebraic data type\ndata ADT name ref =\n       ADT\n         { declName          :: name\n         , declNumParameters :: Natural\n         , declCons          :: Maybe (ConTree ref)\n         }\n\n-- Constructors are disposed in an optimally balanced, right heavier tree\ndata ConTree ref =\n  Con {\n  -- | The constructor name must be unique in the data type\n  constrName :: String\n  \n  ,constrFieldsTypes :: [Type ref]\n\n  -- | If present, all fields must have a corresponding name\n  ,constrFieldsNames :: Maybe (List String)\n  }\n\n  | ConTree (ConTree ref) (ConTree ref)\n\n-- An Unicode string\ndata String = String (List Char)\n\n-- An Unicode char\n-- Defined as the corresponding unicode point (0..10FFFF hexadecimal)\ndata Char = Char Natural\n\n-- Natural number (non-negative integer)\n-- Defined as the concatenation of a list of Word7 (most significant Word7 first)\n-- 0 is encoded as the empty list\ndata Natural = Natural (List Word7)\n\n-- A, possibly empty, list\ndata List a = Nil\n            | Cons a (List a)\n\n-- An optional value\ndata Maybe a = Nothing\n             | Just a\n\n-- A 7 bits word (0..127 natural)\ndata Word7 = V0 | V1 | V2 | V3 | V4 | V5 | V6 | V7 | V8 | V9 | V10\n           | V11 | V12 | V13 | V14 | V15 | V16 | V17 | V18 | V19 | V20\n           | V21 | V22 | V23 | V24 | V25 | V26 | V27 | V28 | V29 | V30\n           | V31 | V32 | V33 | V34 | V35 | V36 | V37 | V38 | V39 | V40\n           | V41 | V42 | V43 | V44 | V45 | V46 | V47 | V48 | V49 | V50\n           | V51 | V52 | V53 | V54 | V55 | V56 | V57 | V58 | V59 | V60\n           | V61 | V62 | V63 | V64 | V65 | V66 | V67 | V68 | V69 | V70\n           | V71 | V72 | V73 | V74 | V75 | V76 | V77 | V78 | V79 | V80\n           | V81 | V82 | V83 | V84 | V85 | V86 | V87 | V88 | V89 | V90\n           | V91 | V92 | V93 | V94 | V95 | V96 | V97 | V98 | V99 | V100\n           | V101 | V102 | V103 | V104 | V105 | V106 | V107 | V108 | V109 | V110\n           | V111 | V112 | V113 | V114 | V115 | V116 | V117 | V118 | V119 | V120\n           | V121 | V122 | V123 | V124 | V125 | V126 | V127\n\n",Header 2 ("algebraic-datatype-definitions",[],[]) [Str "Algebraic",Space,Str "Datatype",Space,Str "Definitions"],Para [Str "Algebraic",Space,Str "datatype",Space,Str "declaration",Space,Str "are",Space,Str "used",Space,Str "to",Space,Str "introduce",Space,Str "new",Space,Str "datatypes",Space,Str "and",Space,Str "therefore",Space,Str "new",Space,Str "constructors."],Para [Str "Some",Space,Str "examples",Space,Str "follow."],Para [Str "A",Space,Str "datatype",Space,Str "that",Space,Str "contains",Space,Str "no",Space,Str "values:"],CodeBlock ("",["haskell"],[]) "data Empty",Para [Str "A",Space,Str "datatype",Space,Str "with",Space,Str "a",Space,Str "single",Space,Str "value",Space,Str "(note",Space,Str "that",Space,Str "the",Space,Str "datatype",Space,Str "name",Space,Str "can",Space,Str "be",Space,Str "the",Space,Str "same",Space,Str "as",Space,Str "the",Space,Str "name",Space,Str "of",Space,Str "one",Space,Str "of",Space,Str "its",Space,Str "constructors):"],CodeBlock ("",["haskell"],[]) "data () = ()",Para [Str "A",Space,Str "datatype",Space,Str "with",Space,Str "two",Space,Str "values:"],CodeBlock ("",["haskell"],[]) "data Bool = False | True",Para [Str "A",Space,Str "simple",Space,Str "recursive",Space,Str "datatype",Space,Str "(a",Space,Str "representation",Space,Str "of",Space,Str "the",Space,Str "natural",Space,Str "numbers):"],CodeBlock ("",["haskell"],[]) "data N = Z | S N\n\nzero = Z\n\none = S Z\n\ntwo = S (S Z)\n\nthree = S two",Para [Str "A",Space,Str "parametric",Space,Str "datatype:"],CodeBlock ("",["haskell"],[]) "data Maybe a = Nothing | Just a",Para [Str "A",Space,Str "parametric",Space,Str "datatype",Space,Str "with",Space,Str "two",Space,Str "variables:"],CodeBlock ("",["haskell"],[]) "data Either a b = Left a | Right b",Para [Str "A",Space,Str "parametric",Space,Str "and",Space,Str "recursive",Space,Str "nested",Space,Str "datatype",Space,Str "(a",Space,Str "list",Space,Str "type):"],CodeBlock ("",["haskell"],[]) "data List a = Nil               -- An empty list.\n            | Cons a (List a)   -- A list: a value followed by another list.",Para [Str "Another",Space,Str "list",Space,Str "datatype,",Space,Str "using",Space,Str "symbols",Space,Str "as",Space,Str "constructor",Space,Str "names:"],CodeBlock ("",["haskell"],[]) "data [] a = []             -- An empty list.\n            | : a ([] a)   -- A list: a value followed by another list.",HorizontalRule,Para [Str "Value",Space,Str "declarations",Space,Str "have",Space,Str "the",Space,Str "following",Space,Str "syntax:"],Para [Emph [Str "valueDecl"],Space,Str "=",Space,Emph [Str "name"],Space,Code ("",[],[]) "=",Space,Emph [Str "value"]],Para [Emph [Str "value"],Space,Str "=",Space,Emph [Str "id"],Space,Str "|",Space,Emph [Str "value"],Space,Emph [Str "value"],Space,Str "|",Space,Code ("",[],[]) "(",Emph [Str "value"],Code ("",[],[]) ")"],Para [Str "Algebraic",Space,Str "datatype",Space,Str "declarations",Space,Str "have",Space,Str "the",Space,Str "following",Space,Str "syntax:"],Para [Code ("",[],[]) "data",Space,Emph [Str "id"],Space,Str "{",Emph [Str "variable"],Str "}~0..",Space,Str "[",Code ("",[],[]) "=",Space,Emph [Str "constructor"],Space,Str "{",Code ("",[],[]) "|",Space,Emph [Str "constructor"],Str "}]"],Para [Emph [Str "constructor"],Space,Str "=",Space,Emph [Str "id"],Space,Str "{",Emph [Str "type"],Str "}"],Para [Emph [Str "type"],Space,Str "=",Space,Emph [Str "id"],Space,Str "|",Space,Emph [Str "variable"],Space,Str "|",Space,Emph [Str "type"],Space,Emph [Str "type"],Space,Str "|",Space,Code ("",[],[]) "(",Emph [Str "type"],Code ("",[],[]) ")"],Para [Emph [Str "id"],Space,Str "=",Space,Emph [Str "name"],Space,Str "|",Space,Emph [Str "symbol"]],Para [Emph [Str "name"],Space,Str "=",Space,Str "an",Space,Str "identifier",Space,Str "beginning",Space,Str "with",Space,Str "an",Space,Str "uppercase",Space,Str "letter"],Para [Emph [Str "symbol"],Space,Str "=",Space,Str "an",Space,Str "identifier",Space,Str "composed",Space,Str "of",Space,Str "non-alphanumeric",Space,Str "characters"],Para [Emph [Str "variable"],Space,Str "=",Space,Str "an",Space,Str "identifier",Space,Str "beginning",Space,Str "with",Space,Str "a",Space,Str "lowercase",Space,Str "letter"],Para [Str "Where:"],BulletList [[Plain [Code ("",[],[]) "data",Space,Str ",",Space,Code ("",[],[]) "=",Space,Str ",",Space,Code ("",[],[]) "|",Space,Str "...",Space,Str "are",Space,Str "keywords"]],[Plain [Str "|",Space,Str "indicates",Space,Str "an",Space,Str "alternative",Space,Str "between",Space,Str "two",Space,Str "elements"]],[Plain [Str "{}",Subscript [Str "n..m"],Space,Str "indicates",Space,Str "an",Space,Str "element",Space,Str "repeated",Space,Str "between",Space,Str "n",Space,Str "and",Space,Str "m",Space,Str "times"]],[Plain [Str "[]",Space,Str "indicates",Space,Str "an",Space,Str "optional",Space,Str "element",Space,Str "(a",Space,Str "shorthand",Space,Str "for",Space,Str "{}",Subscript [Str "0..1"],Str ")"]]],Para [Str "Note:",Space,Str "to",Space,Str "avoid",Space,Str "ambiguity",Space,Str "with",Space,Str "variables,",Space,Str "we",Space,Str "restrict",Space,Str "data",Space,Str "types",Space,Str "and",Space,Str "constructor",Space,Str "names",Space,Str "to",Space,Str "start",Space,Str "with",Space,Str "an",Space,Str "upper",Space,Str "case",Space,Str "letter,",Space,Str "though",Space,Str "this",Space,Str "is",Space,Str "good",Space,Str "practice",Space,Str "is",Space,Str "not",Space,Str "required",Space,Str "by",Space,Str "the",Space,Str "model."],Para [Str "TOFIX:",Space,Str "does",Space,Str "not",Space,Str "support",Space,Str "constructor",Space,Str "field",Space,Str "names."],HorizontalRule,Header 3 ("why-algebraic",[],[]) [Str "Why",Space,Str "Algebraic?"],Para [Str "As",Space,Str "an",Space,Str "algebraic",Space,Str "datatypes",Space,Str "is",Space,Str "a",Space,Str "sum",Space,Str "of",Space,Str "(named)",Space,Str "products",Space,Str "of",Space,Str "types,",Space,Str "their",Space,Str "structure",Space,Str "is",Space,Str "similar",Space,Str "to",Space,Str "that",Space,Str "of",Space,Str "ordinary",Space,Str "algebraic",Space,Str "expressions."],Para [Str "Consider",Space,Str "the",Space,Str "following",Space,Str "type:"],CodeBlock ("",["haskell"],[]) "data Either a b = Left a | Right b",Para [Str "How",Space,Str "many",Space,Str "values",Space,Str "does",Space,Str "it",Space,Str "have?"],Para [Code ("",[],[]) "Either",Space,Str "contains",Space,Str "all",Space,Str "the",Space,Code ("",[],[]) "Left",Space,Str "values,",Space,Str "that's",Space,Str "to",Space,Str "say",Space,Str "all",Space,Str "values",Space,Str "of",Space,Str "type",Space,Code ("",[],[]) "a",Str ",",Space,Str "plus",Space,Str "all",Space,Str "the",Space,Code ("",[],[]) "Right",Space,Str "values,",Space,Str "that's",Space,Str "to",Space,Str "say",Space,Str "all",Space,Str "the",Space,Str "values",Space,Str "of",Space,Str "type",Space,Code ("",[],[]) "b",Str "."],Para [Str "We",Space,Str "could",Space,Str "say",Space,Str "that:"],Para [Code ("",[],[]) "Either a b = a + b"],Para [Str "Now",Space,Str "consider",Space,Str "the",Space,Str "type:"],CodeBlock ("",["haskell"],[]) "data Both a b = Left a | Right b | Both a b",Para [Str "It",Space,Str "has",Space,Str "all",Space,Str "the",Space,Str "values",Space,Str "of",Space,Code ("",[],[]) "Either",Space,Str "plus",Space,Str "the",Space,Str "values",Space,Str "added",Space,Str "by",Space,Str "the",Space,Code ("",[],[]) "Both",Space,Str "constructor."],Para [Str "How",Space,Str "many",Space,Str "values",Space,Str "can",Space,Str "be",Space,Str "created",Space,Str "using",Space,Str "the",Space,Code ("",[],[]) "Both",Space,Str "constructor?"],Para [Str "For",Space,Str "every",Space,Code ("",[],[]) "a",Space,Str "value",Space,Str "we",Space,Str "can",Space,Str "have",Space,Str "any",Space,Code ("",[],[]) "b",Space,Str "value",Space,Str "so",Space,Str "the",Space,Str "number",Space,Str "of",Space,Code ("",[],[]) "Both",Space,Str "values",Space,Str "is",Space,Str "equal",Space,Str "to",Space,Str "the",Space,Str "number",Space,Str "of",Space,Code ("",[],[]) "a",Space,Str "values",Space,Str "multiplied",Space,Str "by",Space,Str "the",Space,Str "number",Space,Str "of",Space,Code ("",[],[]) "b",Space,Str "values."],Para [Str "We",Space,Str "could",Space,Str "say",Space,Str "that:"],Para [Code ("",[],[]) "Both a b = a + b + a * b"],Para [Str "Doesn't",Space,Str "that",Space,Str "look",Space,Str "precisely",Space,Str "like",Space,Str "one",Space,Str "of",Space,Str "these",Space,Str "little",Space,Str "algebraic",Space,Str "formula",Space,Str "that",Space,Str "we",Space,Str "all",Space,Str "studied",Space,Str "at",Space,Str "primary",Space,Str "school?"],Para [Str "Syntactically,",Space,Str "the",Space,Str "only",Space,Str "difference",Space,Str "is",Space,Str "that",Space,Str "in",Space,Str "the",Space,Str "datatype",Space,Str "definition",Space,Str "we:"],BulletList [[Plain [Str "give",Space,Str "an",Space,Str "explicit",Space,Str "name",Space,Str "to",Space,Str "every",Space,Str "term"]],[Plain [Str "write",Space,Str "+",Space,Str "as",Space,Str "|"]],[Plain [Str "don't",Space,Str "explicitly",Space,Str "write",Space,Str "*",Space,Str "(just",Space,Str "as",Space,Str "we",Space,Str "usually",Space,Str "do",Space,Str "in",Space,Str "algebra)"]]],Para [Str "Applying",Space,Str "these",Space,Str "rules",Space,Str "the",Space,Str "algebraic",Space,Str "formula:"],Para [Code ("",[],[]) "Both a b = a + b + a * b"],Para [Str "translates",Space,Str "precisely",Space,Str "back",Space,Str "to",Space,Str "our",Space,Str "algebraic",Space,Str "datatype",Space,Str "definition:"],CodeBlock ("",["haskell"],[]) "data Both a b = Left a | Right b | Both a b"]