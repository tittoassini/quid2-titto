Pandoc (Meta {unMeta = fromList [("author",MetaList [MetaInlines [Str "Pasqualino",Space,Str "'Titto'",Space,Str "Assini",Space,Str "(tittoassini@gmail.com)"]]),("date",MetaInlines [Str "4",Superscript [Str "th"],Space,Str "of",Space,Str "November",Space,Str "2013"]),("title",MetaInlines [Str "Quid2",Space,Str "Manual",Space,Str "(Draft)"])]}) [Para [Str "For",Space,Str "more",Space,Str "information",Space,Str "and",Space,Str "the",Space,Str "most",Space,Str "recent",Space,Str "version",Space,Str "of",Space,Str "this",Space,Str "specification",Space,Str "check",Space,Link [Str "http://quid2.org"] ("http://quid2.org",""),Str "."],Header 1 ("what-is-quid2",[],[]) [Str "What",Space,Str "is",Space,Str "Quid2?"],Para [Str "Quid2",Note [Para [Str "Quid2",Space,Str "is",Space,Str "read",Space,Str "as",Space,Emph [Str "quidquid"],Str ",",Space,Str "a",Space,Str "Latin",Space,Str "word",Space,Str "meaning",Space,Emph [Str "anything"],Space,Str "or",Space,Emph [Str "whatever"],Str ".",Space,Str "The",Space,Str "name",Space,Str "suggests",Space,Str "that",Space,Str "Quid2",Space,Str "is",Space,Str "meant",Space,Str "to",Space,Str "be",Space,Str "an",Space,Str "open",Space,Str "and",Space,Str "universal",Space,Str "system.",Space,Str "Why",Space,Str "a",Space,Str "Latin",Space,Str "name?",Space,Str "Obviously",Space,Str "because",Space,Emph [Str "quidquid",Space,Str "Latine",Space,Str "dictum",Space,Str "sit",Space,Str "altum",Space,Str "videtur"],Str "."]],Space,Str "is",Space,Str "a",Space,Str "novel",Space,Str "approach",Space,Str "to",Space,Str "the",Space,Str "creation",Space,Str "of",Space,Str "open,",Space,Str "evolvable,",Space,Str "consistent",Space,Str "and",Space,Str "efficient",Space,Str "distributed",Space,Str "systems."],Para [Str "It",Space,Str "aims",Space,Str "to",Space,Str "be",Space,Str "as",Space,Str "simple",Space,Str "and",Space,Str "pragmatic",Space,Str "as",Space,Str "possible",Space,Str "but",Space,Str "also",Space,Str "expressive",Space,Str "enough",Space,Str "to",Space,Str "represent",Space,Str "and",Space,Str "exchange",Space,Str "any",Space,Str "kind",Space,Str "of",Space,Str "information",Space,Str "and",Space,Str "implement",Space,Str "any",Space,Str "kind",Space,Str "of",Space,Str "distributed",Space,Str "system."],Para [Str "It",Space,Str "consists",Space,Str "of:"],BulletList [[Para [Str "A",Space,Str "flexible",Space,Str "evaluation",Space,Str "model",Space,Str "to",Space,Str "coordinate",Space,Str "and",Space,Str "exchange",Space,Str "information",Space,Str "across",Space,Str "distributed",Space,Str "agents."]],[Para [Str "A",Space,Str "simple",Space,Str "yet",Space,Str "expressive",Space,Str "and",Space,Str "precise",Space,Str "language",Space,Str "to",Space,Str "define",Space,Strong [Str "globally",Space,Str "unique"],Space,Str "data",Space,Str "types."]],[Para [Str "An",Space,Str "abstract",Space,Str "network",Space,Str "protocol",Space,Str "plus",Space,Str "a",Space,Str "set",Space,Str "of",Space,Str "concrete",Space,Str "implementations",Space,Str "to",Space,Str "communicate",Space,Str "in",Space,Str "different",Space,Str "network",Space,Str "environments",Space,Str "(single",Space,Str "process,",Space,Str "Internet,",Space,Str "Web",Space,Str "clients)."]],[Para [Str "An",Space,Str "efficient",Space,Str "serialisation",Space,Str "format",Space,Str "to",Space,Str "store",Space,Str "and",Space,Str "transfer",Space,Str "values",Space,Str "of",Space,Str "potentially",Space,Str "unlimited",Space,Str "size."]]],Header 2 ("why-is-quid2-or-a-close-relative-needed",[],[]) [Str "Why",Space,Str "Is",Space,Str "Quid2",Space,Str "(Or",Space,Str "A",Space,Str "Close",Space,Str "Relative)",Space,Str "Needed?"],Para [Str "Consider",Space,Str "the",Space,Str "following",Space,Str "scenario:",Space,Str "a",Space,Str "user,",Space,Str "connected",Space,Str "to",Space,Str "the",Space,Str "Internet",Space,Str "via",Space,Str "a",Space,Str "slow",Space,Str "link,",Space,Str "urgently",Space,Str "needs",Space,Str "to",Space,Str "print",Space,Str "a",Space,Str "very",Space,Str "big",Space,Str "spreadsheet,",Space,Str "appropriately",Space,Str "named",Space,Code ("",[],[]) "BS.XSL",Str ",",Space,Str "in",Space,Str "her",Space,Str "office."],Para [Str "The",Space,Str "office",Space,Str "provides",Space,Str "three",Space,Str "services:"],BulletList [[Plain [Str "a",Space,Str "store",Space,Str "where",Space,Str "documents",Space,Str "are",Space,Str "held"]],[Plain [Str "a",Space,Str "converter",Space,Str "that",Space,Str "can",Space,Str "transform",Space,Str "a",Space,Str "spreadsheet",Space,Str "document",Space,Str "to",Space,Str "a",Space,Str "PDF",Space,Str "document"]],[Plain [Str "a",Space,Str "printer",Space,Str "that",Space,Str "can",Space,Str "print",Space,Str "PDF",Space,Str "documents"]]],Para [Str "The",Space,Str "initial",Space,Str "situation",Space,Str "is",Space,Str "the",Space,Str "following:"],Para [Image [Str "A",Space,Str "Coordination",Space,Str "Problem"] ("/Users/titto/workspace/quid2-docs/src/Quid2/Doc/coordinationInitial.pdf","fig:")],Para [Str "A",Space,Str "brief",Space,Str "explanation",Space,Str "about",Space,Str "the",Space,Str "diagram,",Space,Str "the",Space,Str "functionality",Space,Str "provided",Space,Str "by",Space,Str "every",Space,Str "service",Space,Str "is",Space,Str "neatly",Space,Str "specified",Space,Str "by",Space,Str "a",Space,Str "list",Space,Str "of",Space,Str "function",Space,Str "signatures:"],BulletList [[Para [Str "Converter's",Space,Code ("",[],[]) "convert::Doc -> PDF",Space,Str "is",Space,Str "a",Space,Str "pure",Space,Str "function",Space,Str "that",Space,Str "given",Space,Str "a",Space,Str "document",Space,Str "(a",Space,Code ("",[],[]) "Doc",Str ")",Space,Str "will",Space,Str "return",Space,Str "a",Space,Code ("",[],[]) "PDF",Space,Str "document.",Space,Str "Pure",Space,Str "means",Space,Str "that",Space,Code ("",[],[]) "convert",Space,Str "works",Space,Str "just",Space,Str "like",Space,Str "a",Space,Str "mathematical",Space,Str "function:",Space,Str "given",Space,Str "a",Space,Str "certain",Space,Str "input",Space,Str "it",Space,Str "will",Space,Str "always",Space,Str "return",Space,Str "the",Space,Str "same",Space,Str "output",Space,Str "(",Code ("",[],[]) "2+2",Space,Str "always",Space,Str "equals",Space,Code ("",[],[]) "4",Str ").",Space,Str "A",Space,Str "given",Space,Code ("",[],[]) "Doc",Space,Str "will",Space,Str "always",Space,Str "be",Space,Str "converted",Space,Str "to",Space,Str "the",Space,Str "same",Space,Str "identical",Space,Code ("",[],[]) "PDF",Str "."]],[Para [Str "Store's",Space,Code ("",[],[]) "doc::String -> IO Doc",Space,Str "is",Space,Str "an",Space,Str "impure",Space,Str "function",Space,Str "that",Space,Str "given",Space,Str "a",Space,Str "document",Space,Str "name",Space,Str "will",Space,Str "return",Space,Str "the",Space,Str "corresponding",Space,Str "file.",Space,Str "We",Space,Str "know",Space,Str "that",Space,Str "is",Space,Str "impure",Space,Str "because",Space,Str "it",Space,Str "doesn't",Space,Str "return",Space,Str "a",Space,Code ("",[],[]) "Doc",Space,Str "but",Space,Str "an",Space,Code ("",[],[]) "IO Doc",Str ".",Space,Str "The",Space,Str "IO",Space,Str "means",Space,Str "that",Space,Str "this",Space,Str "is",Space,Str "an",Space,Str "Input/Output",Space,Str "function",Space,Str "that",Space,Str "gets",Space,Str "its",Space,Str "hands",Space,Str "dirty",Space,Str "by",Space,Str "somehow",Space,Str "interacting",Space,Str "with",Space,Str "the",Space,Str "external",Space,Str "world,",Space,Str "in",Space,Str "this",Space,Str "case",Space,Str "presumably",Space,Str "a",Space,Str "hard",Space,Str "disk",Space,Str "where",Space,Str "documents",Space,Str "are",Space,Str "stored.",Space,Str "If",Space,Str "we",Space,Str "apply",Space,Str "the",Space,Str "same",Space,Str "function",Space,Str "again",Space,Str "at",Space,Str "a",Space,Str "later",Space,Str "time",Space,Str "we",Space,Str "might",Space,Str "get",Space,Str "a",Space,Str "different",Space,Str "result",Space,Str "as",Space,Str "the",Space,Str "document",Space,Str "stored",Space,Str "under",Space,Str "the",Space,Str "name",Space,Str "\"BS.XSL\"",Space,Str "in",Space,Str "the",Space,Str "disk",Space,Str "might",Space,Str "have",Space,Str "been",Space,Str "udpated."]],[Para [Str "The",Space,Str "Printer's",Space,Code ("",[],[]) "print::PDF -> IO ()",Space,Str "is",Space,Str "an",Space,Str "impure",Space,Str "function",Space,Str "that",Space,Str "given",Space,Str "a",Space,Code ("",[],[]) "PDF",Space,Str "file",Space,Str "will",Space,Str "print",Space,Str "it",Space,Str "and",Space,Str "return",Space,Str "an",Space,Code ("",[],[]) "()",Str ".",Space,Code ("",[],[]) "()",Space,Str "is",Space,Str "a",Space,Str "nullary",Space,Str "(empty)",Space,Str "value,",Space,Str "returned",Space,Str "just",Space,Str "to",Space,Str "let",Space,Str "us",Space,Str "know",Space,Str "that",Space,Str "the",Space,Str "printer",Space,Str "has",Space,Str "successfully",Space,Str "completed",Space,Str "its",Space,Str "job.",Space,Str "The",Space,Str "function",Space,Str "is",Space,Str "obviously",Space,Str "impure:",Space,Str "if",Space,Str "we",Space,Str "try",Space,Str "to",Space,Str "print",Space,Str "the",Space,Str "same",Space,Str "document",Space,Str "again",Space,Str "we",Space,Str "might",Space,Str "receive",Space,Str "an",Space,Str "\"Out",Space,Str "of",Space,Str "Paper\"",Space,Str "error",Space,Str "rather",Space,Str "than",Space,Str "a",Space,Str "nice",Space,Str "round",Space,Code ("",[],[]) "()",Str ".",Space,Str "The",Space,Str "output",Space,Str "of",Space,Str "the",Space,Str "function",Space,Str "depends",Space,Str "on",Space,Str "the",Space,Str "state",Space,Str "of",Space,Str "the",Space,Str "world",Space,Str "and",Space,Str "as",Space,Str "the",Space,Str "world",Space,Str "changes",Space,Str "all",Space,Str "the",Space,Str "time",Space,Str "(paper",Space,Str "finishes,",Space,Str "toner",Space,Str "get",Space,Str "stolen),",Space,Str "the",Space,Str "same",Space,Str "result",Space,Str "cannot",Space,Str "be",Space,Str "guaranteed."]]],Para [Str "Neither",Space,Str "of",Space,Str "these",Space,Str "services",Space,Str "in",Space,Str "isolation",Space,Str "can",Space,Str "provide",Space,Str "the",Space,Str "service",Space,Str "that",Space,Str "the",Space,Str "user",Space,Str "needs",Space,Str "so",Space,Str "some",Space,Str "coordination",Space,Str "will",Space,Str "be",Space,Str "needed,",Space,Str "so",Space,Str "what",Space,Str "is",Space,Str "she",Space,Str "to",Space,Str "do?"],Header 3 ("manual-coordination",[],[]) [Str "Manual",Space,Str "Coordination"],Para [Str "The",Space,Str "user",Space,Str "might",Space,Str "coordinate",Space,Str "these",Space,Str "services",Space,Str "directly",Space,Str "and",Space,Str "manually:",Space,Str "the",Space,Str "following",Space,Str "diagram",Space,Str "shows",Space,Str "how",Space,Str "she",Space,Str "might",Space,Str "go",Space,Str "about",Space,Str "it,",Space,Str "connecting",Space,Str "to",Space,Str "each",Space,Str "service",Space,Str "in",Space,Str "turn",Space,Str "and",Space,Str "moving",Space,Str "data",Space,Str "back",Space,Str "and",Space,Str "forth",Note [Para [Str "An",Space,Str "arrow",Space,Str "indicates",Space,Str "that",Space,Str "some",Space,Str "information",Space,Str "is",Space,Str "being",Space,Str "transferred",Space,Str "from",Space,Str "one",Space,Str "agent",Space,Str "to",Space,Str "another.",Space,Str "The",Space,Str "first",Space,Str "number",Space,Str "in",Space,Str "the",Space,Str "arrow's",Space,Str "label",Space,Str "indicates",Space,Str "the",Space,Str "time",Space,Str "at",Space,Str "which",Space,Str "the",Space,Str "transfer",Space,Str "takes",Space,Str "place.",Space,Str "A",Space,Str "dotted",Space,Str "line",Space,Str "indicates",Space,Str "a",Space,Str "slow",Space,Str "link,",Space,Str "a",Space,Str "full",Space,Str "line",Space,Str "a",Space,Str "fast",Space,Str "one."]],Str "."],Para [Image [Str "Manual",Space,Str "Coordination"] ("/Users/titto/workspace/quid2-docs/src/Quid2/Doc/coordinationManual.pdf","fig:")],Para [Str "It",Space,Str "works,",Space,Str "but",Space,Str "is",Space,Str "cumbersome",Space,Str "and",Space,Str "not",Space,Str "particularly",Space,Str "efficient:",Space,Str "what",Space,Str "might",Space,Str "be",Space,Str "rather",Space,Str "bulky",Space,Str "documents",Space,Str "are",Space,Str "transferred",Space,Str "multiple",Space,Str "times",Space,Str "on",Space,Str "a",Space,Str "slow",Space,Str "connection."],Header 3 ("a-custom-front-end",[],[]) [Str "A",Space,Str "Custom",Space,Str "Front",Space,Str "End"],Para [Str "There",Space,Str "is",Space,Str "another",Space,Str "solution:",Space,Str "maybe",Space,Str "our",Space,Str "user",Space,Str "has",Space,Str "been",Space,Str "prevident",Space,Str "and",Space,Str "before",Space,Str "leaving",Space,Str "office",Space,Str "she",Space,Str "has",Space,Str "created",Space,Str "a",Space,Str "custom",Space,Str "front",Space,Str "end,",Space,Str "an",Space,Str "agent",Space,Str "that",Space,Str "knows",Space,Str "all",Space,Str "about",Space,Str "printing",Space,Str "her",Space,Str "BS",Space,Str "document."],Para [Image [Str "Custom",Space,Str "Solution"] ("/Users/titto/workspace/quid2-docs/src/Quid2/Doc/coordinationCustom.pdf","fig:")],Para [Str "It's",Space,Str "a",Space,Str "brilliant",Space,Str "solution:",Space,Str "all",Space,Str "she",Space,Str "needs",Space,Str "to",Space,Str "do",Space,Str "is",Space,Str "to",Space,Str "get",Space,Str "the",Space,Str "process",Space,Str "started,",Space,Str "the",Space,Str "custom",Space,Str "front-end",Space,Str "then",Space,Str "takes",Space,Str "care",Space,Str "of",Space,Str "all",Space,Str "the",Space,Str "coordination."],Para [Str "It's",Space,Str "also",Space,Str "efficient",Space,Str "as",Space,Str "most",Space,Str "communication",Space,Str "takes",Space,Str "place",Space,Str "on",Space,Str "local",Space,Str "high",Space,Str "speed",Space,Str "links."],Para [Str "But",Space,Str "what",Space,Str "if",Space,Str "she",Space,Str "wants",Space,Str "to",Space,Str "print",Space,Str "a",Space,Str "different",Space,Str "document?",Space,Str "Or",Space,Str "if",Space,Str "she",Space,Str "has",Space,Str "different",Space,Str "kinds",Space,Str "of",Space,Str "documents",Space,Str "to",Space,Str "print?",Space,Str "Or",Space,Str "if",Space,Str "occasionally",Space,Str "some",Space,Str "additional",Space,Str "conversion",Space,Str "or",Space,Str "reformatting",Space,Str "operation",Space,Str "is",Space,Str "required?",Space,Str "How",Space,Str "many",Space,Str "different",Space,Str "custom",Space,Str "functions",Space,Str "will",Space,Str "she",Space,Str "need",Note [Para [Str "The",Space,Str "idea",Space,Str "that",Space,Str "one",Space,Str "might",Space,Str "design",Space,Str "a",Space,Str "system",Space,Str "as",Space,Str "an",Space,Str "unwieldy",Space,Str "set",Space,Str "of",Space,Emph [Str "ad-hoc"],Space,Str "functions",Space,Str "sounds",Space,Str "absolutely",Space,Str "preposterous",Space,Str "till",Space,Str "one",Space,Str "realises",Space,Str "that",Space,Str "this",Space,Str "is",Space,Str "exactly",Space,Str "how",Space,Str "99%",Space,Str "of",Space,Str "Web",Space,Str "sites",Space,Str "are",Space,Str "made."]],Str "?"],Header 3 ("distributed-evaluation",[],[]) [Str "Distributed",Space,Str "Evaluation"],Para [Str "There",Space,Str "is",Space,Str "a",Space,Str "better",Space,Str "way.",Space,Str "At",Space,Str "the",Space,Str "place",Space,Str "of",Space,Str "the",Space,Str "rigid",Space,Str "custom",Space,Str "front",Space,Str "end,",Space,Str "she",Space,Str "puts",Space,Str "a",Space,Str "flexible",Space,Str "Coordinator",Space,Str "that",Space,Str "has",Space,Str "the",Space,Str "capability",Space,Str "of",Space,Str "evaluating",Space,Str "simple",Space,Str "expressions."],Para [Str "She",Space,Str "can",Space,Str "now",Space,Str "send",Space,Str "an",Space,Str "expression",Space,Str "that,",Space,Str "when",Space,Str "executed",Space,Str "by",Space,Str "the",Space,Str "Coordinator,",Space,Str "will",Space,Str "do",Space,Str "exactly",Space,Str "what",Space,Str "she",Space,Str "requires:"],Para [Code ("",[],[]) "Store.doc \"BS.XSL\" >>= Printer.print . Converter.convert"],Para [Str "The",Space,Str "Coordinator",Space,Str "implements",Space,Str "just",Space,Str "two",Space,Str "additional,",Space,Str "but",Space,Str "very",Space,Str "powerful,",Space,Str "higher",Space,Str "order",Note [Para [Str "A",Space,Str "higher",Space,Str "order",Space,Str "function",Space,Str "is",Space,Str "a",Space,Str "function",Space,Str "that",Space,Str "takes",Space,Str "as",Space,Str "inputs",Space,Str "and/or",Space,Str "returns",Space,Str "other",Space,Str "functions."]],Space,Str "functions:"],BulletList [[Para [Code ("",[],[]) "(>>=)::IO a -> (a -> IO b) -> IO b",Space,Str "is",Space,Str "a",Space,Str "sequencing",Space,Str "operation",Space,Str "used",Space,Str "to",Space,Str "bind",Space,Str "together",Space,Str "different",Space,Str "IO",Space,Str "operations",Space,Note [Para [Str "Technically,",Space,Str "it",Space,Str "is",Space,Str "a",Space,Str "monadic",Space,Str "bind",Space,Str "restricted",Space,Str "to",Space,Str "IO."]],Str ".",Space,Str "Given",Space,Str "an",Space,Str "IO",Space,Str "operation",Space,Str "that",Space,Str "returns",Space,Str "some",Space,Str "value",Space,Str "(",Code ("",[],[]) "IO a",Str "),",Space,Str "it",Space,Str "will",Space,Str "execute",Space,Str "it",Space,Str "and",Space,Str "then",Space,Str "feed",Space,Str "its",Space,Str "result",Space,Str "to",Space,Str "the",Space,Str "next",Space,Str "IO",Space,Str "operation",Space,Str "(",Code ("",[],[]) "a -> IO b",Str ").",Space,Str "In",Space,Str "the",Space,Str "example,",Space,Str "it",Space,Str "is",Space,Str "used",Space,Str "to",Space,Str "feed",Space,Str "the",Space,Code ("",[],[]) "Doc",Space,Str "returned",Space,Str "by",Space,Code ("",[],[]) "doc::String -> IO Doc",Space,Str "to",Space,Str "the",Space,Str "print",Space,Str "operation",Space,Str "that",Space,Str "follows."]],[Para [Code ("",[],[]) "(.)::(b -> c) -> (a -> b) -> (a -> c)",Space,Str "is",Space,Str "functional",Space,Str "composition:",Space,Str "given",Space,Str "two",Space,Str "compatible",Space,Str "functions",Space,Str "it",Space,Str "will",Space,Str "return",Space,Str "their",Space,Str "combination.",Space,Str "In",Space,Str "the",Space,Str "example,",Space,Str "the",Space,Code ("",[],[]) "Doc",Space,Str "returned",Space,Str "by",Space,Code ("",[],[]) "doc",Space,Str "cannot",Space,Str "be",Space,Str "printed",Space,Str "directly,",Space,Str "so",Space,Str "we",Space,Str "compose",Space,Code ("",[],[]) "print::PDF -> IO ()",Space,Str "with",Space,Code ("",[],[]) "convert::Doc -> PDF",Space,Str "obtaining",Space,Str "just",Space,Str "what",Space,Str "we",Space,Str "need:",Space,Str "a",Space,Str "print",Space,Str "function",Space,Str "that",Space,Str "given",Space,Str "a",Space,Code ("",[],[]) "Doc",Space,Str "will",Space,Str "print",Space,Str "it",Space,Str "(a",Space,Code ("",[],[]) "Doc -> IO ()",Space,Str "function)."]]],Para [Str "Note",Space,Str "that",Space,Str "the",Space,Code ("",[],[]) "Coordinator",Space,Str "is",Space,Str "totally",Space,Str "generic,",Space,Str "it",Space,Str "can",Space,Str "be",Space,Str "used",Space,Str "to",Space,Str "orchestrate",Space,Str "all",Space,Str "kind",Space,Str "of",Space,Str "activities",Space,Str "and",Space,Str "calculations",Space,Str "across",Space,Str "any",Space,Str "number",Space,Str "of",Space,Str "different",Space,Str "services.",Space,Str "It's",Space,Str "simple",Space,Str "but",Space,Str "totally",Space,Str "flexible",Note [Para [Str "An",Space,Str "intelligent",Space,Str "coordinator",Space,Str "can",Space,Str "also",Space,Str "provide",Space,Str "some",Space,Str "automatic",Space,Str "optimisations.",Space,Str "As",Space,Str "we",Space,Str "mentioned,",Space,Code ("",[],[]) "convert",Space,Str "is",Space,Str "a",Space,Str "pure",Space,Str "function.",Space,Str "It's",Space,Str "also",Space,Str "probably",Space,Str "expensive",Space,Str "in",Space,Str "terms",Space,Str "of",Space,Str "time",Space,Str "and",Space,Str "network",Space,Str "bandwidth.",Space,Str "An",Space,Str "intelligent",Space,Str "coordinator",Space,Str "would",Space,Str "cache",Space,Str "the",Space,Str "result",Space,Str "of",Space,Str "this",Space,Str "operation",Space,Str "and",Space,Str "reuse",Space,Str "it",Space,Str "if",Space,Str "the",Space,Str "same",Space,Str "conversion",Space,Str "is",Space,Str "requested",Space,Str "again,",Space,Str "so",Space,Str "avoiding",Space,Str "to",Space,Str "contact",Space,Str "the",Space,Code ("",[],[]) "Converter",Space,Str "at",Space,Str "all."]],Str "."],Para [Image [Str "Distributed",Space,Str "Evaluation"] ("/Users/titto/workspace/quid2-docs/src/Quid2/Doc/coordinationEvaluator.pdf","fig:")],Header 3 ("extensible-distributed-evaluation",[],[]) [Str "Extensible",Space,Str "Distributed",Space,Str "Evaluation"],Para [Str "Obviously",Space,Str "she",Space,Str "has",Space,Str "lost",Space,Str "the",Space,Str "extreme",Space,Str "simplicity",Space,Str "of",Space,Str "the",Space,Str "custom",Space,Str "solution:",Space,Str "repetitive",Space,Str "operations",Space,Str "now",Space,Str "have",Space,Str "to",Space,Str "be",Space,Str "entered",Space,Str "as,",Space,Str "possibly",Space,Str "verbose,",Space,Str "expression.",Space,Str "This",Space,Str "can",Space,Str "be",Space,Str "easily",Space,Str "fixed",Space,Str "by",Space,Str "adding",Space,Str "to",Space,Str "the",Space,Str "Coordinator",Space,Str "the",Space,Str "capability",Space,Str "of",Space,Str "accepting",Space,Str "definitions",Space,Str "of",Space,Str "new",Space,Str "functions",Note [Para [Str "As",Space,Str "many",Space,Str "other",Space,Str "aspects",Space,Str "of",Space,Str "this",Space,Str "example",Space,Str "application,",Space,Str "this",Space,Str "is",Space,Str "an",Space,Str "oversimplification.",Space,Str "Definitions",Space,Str "will",Space,Str "usually",Space,Str "be",Space,Str "stored",Space,Str "in",Space,Str "separate",Space,Str "repositories",Space,Str "so",Space,Str "that",Space,Str "they",Space,Str "can",Space,Str "be",Space,Str "easily",Space,Str "shared."]],Space,Str "ending",Space,Str "up",Space,Str "with",Space,Str "a",Space,Str "system",Space,Str "that",Space,Str "is",Space,Str "both",Space,Str "flexible",Space,Str "and",Space,Str "concise."],Para [Image [Str "Extensible",Space,Str "Distributed",Space,Str "Evaluation"] ("/Users/titto/workspace/quid2-docs/src/Quid2/Doc/coordinationFinal.pdf","fig:")],Para [Str "Quid2",Space,Str "provides",Space,Str "precisely",Space,Str "the",Space,Str "tools",Space,Str "required",Space,Str "to",Space,Str "build",Space,Str "this",Space,Str "kind",Space,Str "of",Space,Str "simple",Space,Str "but",Space,Str "flexible",Space,Str "and",Space,Str "scalable",Space,Str "solutions."],RawBlock (Format "html") "<!--\nDistributed systems are build using very different models: REST, RPC, streaming, etc.\n\n^[but not simpler, following the *dictum* of you-know-who.]\n\nRPC example:\n(Appl (Prim \"IO>>=\") (Func \"printString\") (Literal ...) (CallBack \"my_cb\"))\n\nSignal example::\n(Appl (Prim \"void\") (Func \"printString\") (Literal ...) (CallBack \"my_cb\"))\n\nStreaming is currently implemented by methods that take persistent\n call backs as parameters:\n\nsubscribe :: CB Int -> Q ()\n\nTo stop streaming, we just delete the CB.\n\nStreaming example (should look at pipes package, maybe even for normal\ncalls):\nprintQuotes :: Security -> Q\n\n## A Global example: buying airplane tickets online\n\n## Developing in Quid2\n\njust like now: users create modules, of which there can be many versions, in their own favourite language | directly in quid2 syntax.\n\nwrite a translator from simple quid2 syntax to full quid2 syntax (is this possible?) \n-->\n",Header 1 ("language",[],[]) [Str "Language"],Para [Str "To",Space,Str "both",Space,Str "explain",Space,Str "and",Space,Str "specify",Space,Str "the",Space,Str "language",Space,Str "at",Space,Str "the",Space,Str "core",Space,Str "of",Space,Str "Quid2",Space,Str "we:"],BulletList [[Para [Str "start",Space,Str "by",Space,Str "quickly",Space,Str "introducing",Space,Str "some",Space,Str "basic",Space,Str "concepts"]],[Para [Str "proceed",Space,Str "to",Space,Str "an",Space,Str "informal",Space,Str "exposition",Space,Str "of",Space,Str "the",Space,Str "Quid2",Space,Str "language",Space,Str "structure"]],[Para [Str "provide",Space,Str "a",Space,Str "formal",Space,Str "specification",Space,Str "of",Space,Str "the",Space,Str "language",Space,Str "abstract",Space,Str "structure",Space,Str "in",Space,Str "the",Space,Str "language",Space,Str "itself"]]],Para [Str "Note",Space,Str "that,",Space,Str "as",Space,Str "Quid2",Space,Str "is",Space,Str "self-defined,",Space,Str "we",Space,Str "sometime",Space,Str "need",Space,Str "to",Space,Str "use",Space,Str "concepts",Space,Str "before",Space,Str "they",Space,Str "are",Space,Str "fully",Space,Str "explained."],Para [Str "It",Space,Str "might",Space,Str "be",Space,Str "advisable",Space,Str "to",Space,Str "start",Space,Str "by",Space,Str "quickly",Space,Str "browsing",Space,Str "the",Space,Str "contents",Space,Str "of",Space,Str "this",Space,Str "chapter,",Space,Str "skipping",Space,Str "what",Space,Str "is",Space,Str "not",Space,Str "immediately",Space,Str "understandable",Space,Str "and",Space,Str "coming",Space,Str "back",Space,Str "to",Space,Str "it",Space,Str "later."],Para [Str "Hopefully",Space,Str "it",Space,Str "will",Space,Str "all",Space,Str "make",Space,Str "sense",Space,Str "in",Space,Str "the",Space,Str "end",Space,Str ":-)"],Header 2 ("basic-concepts",[],[]) [Str "Basic",Space,Str "Concepts"],Para [Str "The",Space,Str "Quid2",Space,Str "global",Space,Str "space",Space,Str "is",Space,Str "a",Space,Str "distributed",Space,Str "set",Space,Str "of",Space,Str "definitions",Space,Str "(or",Space,Str "declarations,",Space,Str "we",Space,Str "will",Space,Str "use",Space,Str "the",Space,Str "two",Space,Str "terms",Space,Str "interchangeably)",Space,Str "of",Space,Str "functions",Space,Str "and",Space,Str "datatypes."],Para [Str "Quid2",Space,Str "is",Space,Str "a",Space,Str "typed",Space,Str "language",Space,Str "with",Space,Str "a",Space,Str "simple",Space,Str "but",Space,Str "expressive",Space,Str "polymorphic",Space,Str "type",Space,Str "system",Space,Str "and",Space,Str "a",Space,Str "hierarchical",Space,Str "type",Space,Str "hierarchy",Space,Str "(composed",Space,Str "by",Space,Str "values,",Space,Str "types,",Space,Str "kinds,",Space,Str "sorts",Space,Str "and",Space,Str "higher",Space,Str "sorts)."],RawBlock (Format "html") "<!--\nType expression are all assumed to be universally quantified. For example, the type expression *a -> a* denotes the type *forall a. a -> a*.\n-->\n  ",Para [Str "A",Space,Str "function",Space,Str "declaration",Space,Str "binds",Space,Str "a",Space,Str "qualified",Space,Str "name",Space,Str "to",Space,Str "an",Space,Str "expression."],Para [Str "An",Space,Str "expression",Space,Str "denotes",Space,Str "a",Space,Str "value",Space,Str "and",Space,Str "has",Space,Str "a",Space,Str "static",Space,Str "type",Note [Para [Str "A",Space,Str "type",Space,Str "that",Space,Str "can",Space,Str "be",Space,Str "determined",Space,Str "by",Space,Str "a",Space,Str "static",Space,Str "analysis",Space,Str "of",Space,Str "the",Space,Str "expression."]],Str "."],Para [Str "Evaluating",Space,Str "an",Space,Str "expression",Space,Str "consists",Space,Str "in",Space,Str "reducing",Space,Str "an",Space,Str "expression",Space,Str "to",Space,Str "the",Space,Str "value",Space,Str "it",Space,Str "denotes."],Para [Str "Could",Space,Str "as",Space,Str "in",Space,Str "Coq,",Space,Str "evaluation",Space,Str "order",Space,Str "be",Space,Str "itself",Space,Str "a",Space,Str "parameter?",Space,Str "Lazy/Eager",Space,Str "..?",Space,Str "What",Space,Str "would",Space,Str "be",Space,Str "the",Space,Str "advantage?"],Para [Str "A",Space,Str "value",Space,Str "is",Space,Str "composed",Space,Str "by",Space,Str "a",Space,Str "type",Space,Str "and",Space,Str "either:"],BulletList [[Plain [Str "an",Space,Str "array",Space,Str "of",Space,Str "bytes,",Space,Str "built",Space,Str "according",Space,Str "to",Space,Str "the",Space,Link [Str "canonical",Space,Str "serialisation"] ("#serialisation","")]],[Plain [Str "a",Space,Str "function",Space,Str "located",Space,Str "at",Space,Str "some",Space,Str "network",Space,Str "or",Space,Str "local",Space,Str "address"]],[Plain [Str "an",Space,Str "error"]]],Para [Str "A",Space,Str "datatype",Space,Str "declaration",Space,Str "defines",Space,Str "an",Space,Str "algebraic",Space,Str "datatype",Space,Str "(composed",Space,Str "by",Space,Str "one",Space,Str "type",Space,Str "constructor",Space,Str "plus",Space,Str "a",Space,Str "set",Space,Str "of",Space,Str "value",Space,Str "constructors)."],Para [Str "A",Space,Str "constructor",Space,Str "is",Space,Str "a",Space,Str "function",Space,Str "that",Space,Str "creates",Space,Str "a",Space,Str "value",Space,Str "(at",Space,Str "some",Space,Str "level",Space,Str "of",Space,Str "the",Space,Str "type",Space,Str "hierarchy)."],Header 2 ("informal-syntax",[],[]) [Str "Informal",Space,Str "Syntax"],Para [Str "Quid2",Space,Str "does",Space,Str "not",Space,Str "have",Space,Str "a",Space,Str "formally",Space,Str "defined",Space,Str "textual",Space,Str "syntax",Note [Para [Str "It",Space,Str "is",Space,Str "not",Space,Str "clear",Space,Str "if",Space,Str "such",Space,Str "a",Space,Str "surface",Space,Str "syntax",Space,Str "is",Space,Str "needed",Space,Str "at",Space,Str "all,",Space,Str "given",Space,Str "that",Space,Str "Quid2",Space,Str "definitions",Space,Str "will",Space,Str "probably",Space,Str "be",Space,Str "usually",Space,Str "automatically",Space,Str "derived",Space,Str "from",Space,Str "definitions",Space,Str "in",Space,Str "other",Space,Str "languages.",Space,Str "Quid2",Space,Str "abstract",Space,Str "syntax",Space,Str "is",Space,Str "however",Space,Str "very",Space,Str "precisely",Space,Str "defined",Space,Str "in",Space,Str "Quid2",Space,Str "itself."]],Str "."],Para [Str "However,",Space,Str "for",Space,Str "the",Space,Str "purpose",Space,Str "of",Space,Str "this",Space,Str "report,",Space,Str "we",Space,Str "will",Space,Str "briefly",Space,Str "introduce",Space,Str "and",Space,Str "use",Space,Str "a",Space,Str "convenient",Space,Str "informal",Space,Str "syntax."],Header 2 ("constructors",[],[]) [Str "Constructors"],Para [Str "Constructors",Space,Str "are",Space,Str "denoted",Space,Str "by",Space,Str "identifiers",Space,Str "beginning",Space,Str "with",Space,Str "an",Space,Str "uppercase",Space,Str "letter",Space,Str "or",Space,Str "symbols",Space,Str "(identifiers",Space,Str "composed",Space,Str "of",Space,Str "non-alphanumeric",Space,Str "characters)."],Para [Str "Constructors",Space,Str "can",Space,Str "be",Space,Str "applied",Space,Str "to",Space,Str "one",Space,Str "or",Space,Str "more",Space,Str "other",Space,Str "values."],Para [Str "Some",Space,Str "examples:"],CodeBlock ("",["haskell"],[]) "False    -- boolean false\n\nTrue     -- boolean true\n\n-- a missing optional value\nNothing  \n\n-- a present optional value\n-- Just is applied to True and together form a single value.  \nJust True\n\n-- the nullary value\n()",Para [Str "There",Space,Str "is",Space,Str "a",Space,Str "special",Space,Str "syntax",Space,Str "for",Space,Str "numbers,",Space,Str "chars",Space,Str "and",Space,Str "strings",Space,Str "constructors:"],CodeBlock ("",["haskell"],[]) "1     -- a positive integer\n\n-5    -- a negative integer\n\n3.14  -- a floating point\n\n'a'   -- the character a\n\n\"a string\" -- a unicode string",Para [Str "There",Space,Str "is",Space,Str "also",Space,Str "a",Space,Str "special",Space,Str "syntax",Space,Str "for",Space,Str "two",Space,Str "common",Space,Str "data",Space,Str "structures:",Space,Str "lists",Space,Str "(unlimited",Space,Str "sequences",Space,Str "of",Space,Str "values",Space,Str "of",Space,Str "the",Space,Str "same",Space,Str "type)",Space,Str "and",Space,Str "tuples",Space,Str "(fixed",Space,Str "sequences",Space,Str "of",Space,Str "values",Space,Str "of",Space,Str "possibly",Space,Str "different",Space,Str "types):"],CodeBlock ("",["haskell"],[]) "-- a list of integers\n[1,2,3] \n\n-- a tuple composed by a char, a string and an integer\n('a',\"bc\",22) ",RawBlock (Format "html") "<!--\n### Tuples \nA tuple is a sequence of values, of possibly different types.\n\nTuples can be of arbitrary length (0..) (|| or length>=2).\n\n```haskell\ndata Tuple0 = Tuple0\n\ndata Tuple1 a = Tuple1 a\n\ndata Tuple2 a b = Tuple2 a b\n\ndata () = () \n\n-- missing: data (_) a b = (_) a b\n\ndata (,) a b = (,,) a b\n\ndata (,,) a b c = (,,) a b c\n```\n\nOr we might have just the couple (,) and define all tuples as nested appls of it = (,,) = (,) a (,) b c \n-->\n",Header 2 ("algebraic-datatype-definitions",[],[]) [Str "Algebraic",Space,Str "Datatype",Space,Str "Definitions"],Para [Str "Algebraic",Space,Str "datatype",Space,Str "declaration",Space,Str "are",Space,Str "used",Space,Str "to",Space,Str "introduce",Space,Str "new",Space,Str "datatypes",Space,Str "and",Space,Str "therefore",Space,Str "new",Space,Str "constructors."],Para [Str "Some",Space,Str "examples",Space,Str "follow."],Para [Str "A",Space,Str "datatype",Space,Str "that",Space,Str "contains",Space,Str "no",Space,Str "values:"],CodeBlock ("",["haskell"],[]) "data Empty",Para [Str "A",Space,Str "datatype",Space,Str "with",Space,Str "a",Space,Str "single",Space,Str "value",Space,Str "(note",Space,Str "that",Space,Str "the",Space,Str "datatype",Space,Str "name",Space,Str "can",Space,Str "be",Space,Str "the",Space,Str "same",Space,Str "as",Space,Str "the",Space,Str "name",Space,Str "of",Space,Str "one",Space,Str "of",Space,Str "its",Space,Str "constructors):"],CodeBlock ("",["haskell"],[]) "data () = ()",Para [Str "A",Space,Str "datatype",Space,Str "with",Space,Str "two",Space,Str "values:"],CodeBlock ("",["haskell"],[]) "data Bool = False | True",Para [Str "A",Space,Str "simple",Space,Str "recursive",Space,Str "datatype",Space,Str "(a",Space,Str "representation",Space,Str "of",Space,Str "the",Space,Str "natural",Space,Str "numbers):"],CodeBlock ("",["haskell"],[]) "data N = Z | S N\n\nzero = Z\n\none = S Z\n\ntwo = S (S Z)\n\nthree = S two",Para [Str "A",Space,Str "parametric",Space,Str "datatype:"],CodeBlock ("",["haskell"],[]) "data Maybe a = Nothing | Just a",Para [Str "A",Space,Str "parametric",Space,Str "datatype",Space,Str "with",Space,Str "two",Space,Str "variables:"],CodeBlock ("",["haskell"],[]) "data Either a b = Left a | Right b",Para [Str "A",Space,Str "parametric",Space,Str "and",Space,Str "recursive",Space,Str "nested",Space,Str "datatype",Space,Str "(a",Space,Str "list",Space,Str "type):"],CodeBlock ("",["haskell"],[]) "data List a = Nil               -- An empty list.\n            | Cons a (List a)   -- A list: a value followed by another list.",Para [Str "Another",Space,Str "list",Space,Str "datatype,",Space,Str "using",Space,Str "symbols",Space,Str "as",Space,Str "constructor",Space,Str "names:"],CodeBlock ("",["haskell"],[]) "data [] a = []             -- An empty list.\n            | : a ([] a)   -- A list: a value followed by another list.",HorizontalRule,Para [Str "Algebraic",Space,Str "datatype",Space,Str "declarations",Space,Str "have",Space,Str "the",Space,Str "following",Space,Str "syntax:"],Para [Str "[",Code ("",[],[]) "data",Str "]",Space,Emph [Str "simpleType"],Space,Str "[",Code ("",[],[]) "=",Space,Emph [Str "constructor"],Space,Str "{",Code ("",[],[]) "|",Space,Emph [Str "constructor"],Str "}]"],Para [Emph [Str "simpleType"],Space,Str "=",Space,Emph [Str "id"],Space,Str "{",Emph [Str "variable"],Str "}",Subscript [Str "0..256"]],Para [Emph [Str "constructor"],Space,Str "=",Space,Emph [Str "id"],Space,Str "{",Emph [Str "type"],Str "}"],Para [Emph [Str "type"],Space,Str "=",Space,Emph [Str "id"],Space,Str "|",Space,Emph [Str "variable"],Space,Str "|",Space,Emph [Str "type"],Space,Emph [Str "type"],Space,Str "|",Space,Emph [Str "type"],Space,Code ("",[],[]) "->",Space,Emph [Str "type"],Space,Str "|",Space,Code ("",[],[]) "(",Emph [Str "type"],Code ("",[],[]) ",",Emph [Str "type"],Str "{",Code ("",[],[]) ",",Space,Emph [Str "type"],Str "}",Code ("",[],[]) ")",Space,Str "|",Space,Code ("",[],[]) "[",Emph [Str "type"],Code ("",[],[]) "]",Space,Str "|",Space,Code ("",[],[]) "(",Emph [Str "type"],Code ("",[],[]) ")"],Para [Emph [Str "id"],Space,Str "=",Space,Emph [Str "name"],Space,Str "|",Space,Emph [Str "symbol"]],Para [Emph [Str "name"],Space,Str "=",Space,Str "an",Space,Str "identifier",Space,Str "beginning",Space,Str "with",Space,Str "an",Space,Str "uppercase",Space,Str "letter"],Para [Emph [Str "symbol"],Space,Str "=",Space,Str "an",Space,Str "identifier",Space,Str "composed",Space,Str "of",Space,Str "non-alphanumeric",Space,Str "characters"],Para [Emph [Str "variable"],Space,Str "=",Space,Str "an",Space,Str "identifier",Space,Str "beginning",Space,Str "with",Space,Str "a",Space,Str "lowercase",Space,Str "letter"],Para [Str "Where:"],BulletList [[Plain [Code ("",[],[]) "data",Space,Str ",",Space,Code ("",[],[]) "=",Space,Str ",",Space,Code ("",[],[]) "|",Space,Str "...",Space,Str "are",Space,Str "keywords"]],[Plain [Str "|",Space,Str "indicates",Space,Str "an",Space,Str "alternative",Space,Str "between",Space,Str "two",Space,Str "elements"]],[Plain [Str "{}",Subscript [Str "n..m"],Space,Str "indicates",Space,Str "an",Space,Str "element",Space,Str "repeated",Space,Str "between",Space,Str "n",Space,Str "and",Space,Str "m",Space,Str "times"]],[Plain [Str "[]",Space,Str "indicates",Space,Str "an",Space,Str "optional",Space,Str "element",Space,Str "(a",Space,Str "shorthand",Space,Str "for",Space,Str "{}",Subscript [Str "0..1"],Str ")"]]],RawBlock (Format "html") "<!-- * plain texts as (application) are comments\n\nThe prefix \\I or \\i is not considered part of the identifier name. Therefore, \\iperson is just an initial lowercase identifier\nnamed person and \\Iperson is an initial uppercase identifier named person.\n-->\n",HorizontalRule,Header 3 ("why-algebraic",[],[]) [Str "Why",Space,Str "Algebraic?"],Para [Str "As",Space,Str "an",Space,Str "algebraic",Space,Str "datatypes",Space,Str "is",Space,Str "a",Space,Str "sum",Space,Str "of",Space,Str "(named)",Space,Str "products",Space,Str "of",Space,Str "types,",Space,Str "their",Space,Str "structure",Space,Str "is",Space,Str "similar",Space,Str "to",Space,Str "that",Space,Str "of",Space,Str "ordinary",Space,Str "algebraic",Space,Str "expressions."],Para [Str "Consider",Space,Str "the",Space,Str "following",Space,Str "type:"],CodeBlock ("",["haskell"],[]) "data Either a b = Left a | Right b",Para [Str "How",Space,Str "many",Space,Str "values",Space,Str "does",Space,Str "it",Space,Str "have?"],Para [Code ("",[],[]) "Either",Space,Str "contains",Space,Str "all",Space,Str "the",Space,Code ("",[],[]) "Left",Space,Str "values,",Space,Str "that's",Space,Str "to",Space,Str "say",Space,Str "all",Space,Str "values",Space,Str "of",Space,Str "type",Space,Code ("",[],[]) "a",Str ",",Space,Str "plus",Space,Str "all",Space,Str "the",Space,Code ("",[],[]) "Right",Space,Str "values,",Space,Str "that's",Space,Str "to",Space,Str "say",Space,Str "all",Space,Str "the",Space,Str "values",Space,Str "of",Space,Str "type",Space,Code ("",[],[]) "b",Str "."],Para [Str "We",Space,Str "could",Space,Str "say",Space,Str "that:"],Para [Code ("",[],[]) "Either a b = a + b"],Para [Str "Now",Space,Str "consider",Space,Str "the",Space,Str "type:"],CodeBlock ("",["haskell"],[]) "data Both a b = Left a | Right b | Both a b",Para [Str "It",Space,Str "has",Space,Str "all",Space,Str "the",Space,Str "values",Space,Str "of",Space,Code ("",[],[]) "Either",Space,Str "plus",Space,Str "the",Space,Str "values",Space,Str "added",Space,Str "by",Space,Str "the",Space,Code ("",[],[]) "Both",Space,Str "constructor."],Para [Str "How",Space,Str "many",Space,Str "values",Space,Str "can",Space,Str "be",Space,Str "created",Space,Str "using",Space,Str "the",Space,Code ("",[],[]) "Both",Space,Str "constructor?"],Para [Str "For",Space,Str "every",Space,Code ("",[],[]) "a",Space,Str "value",Space,Str "we",Space,Str "can",Space,Str "have",Space,Str "any",Space,Code ("",[],[]) "b",Space,Str "value",Space,Str "so",Space,Str "the",Space,Str "number",Space,Str "of",Space,Code ("",[],[]) "Both",Space,Str "values",Space,Str "is",Space,Str "equal",Space,Str "to",Space,Str "the",Space,Str "number",Space,Str "of",Space,Code ("",[],[]) "a",Space,Str "values",Space,Str "multiplied",Space,Str "by",Space,Str "the",Space,Str "number",Space,Str "of",Space,Code ("",[],[]) "b",Space,Str "values."],Para [Str "We",Space,Str "could",Space,Str "say",Space,Str "that:"],Para [Code ("",[],[]) "Both a b = a + b + a * b"],Para [Str "Doesn't",Space,Str "that",Space,Str "look",Space,Str "precisely",Space,Str "like",Space,Str "one",Space,Str "of",Space,Str "these",Space,Str "little",Space,Str "algebraic",Space,Str "formula",Space,Str "that",Space,Str "we",Space,Str "all",Space,Str "studied",Space,Str "at",Space,Str "primary",Space,Str "school?"],Para [Str "Syntactically,",Space,Str "the",Space,Str "only",Space,Str "difference",Space,Str "is",Space,Str "that",Space,Str "in",Space,Str "the",Space,Str "datatype",Space,Str "definition",Space,Str "we:"],BulletList [[Plain [Str "give",Space,Str "an",Space,Str "explicit",Space,Str "name",Space,Str "to",Space,Str "every",Space,Str "term"]],[Plain [Str "write",Space,Str "+",Space,Str "as",Space,Str "|"]],[Plain [Str "don't",Space,Str "explicitly",Space,Str "write",Space,Str "*",Space,Str "(just",Space,Str "as",Space,Str "we",Space,Str "usually",Space,Str "do",Space,Str "in",Space,Str "algebra)"]]],Para [Str "Applying",Space,Str "these",Space,Str "rules",Space,Str "the",Space,Str "algebraic",Space,Str "formula:"],Para [Code ("",[],[]) "Both a b = a + b + a * b"],Para [Str "translates",Space,Str "precisely",Space,Str "back",Space,Str "to",Space,Str "our",Space,Str "algebraic",Space,Str "datatype",Space,Str "definition:"],CodeBlock ("",["haskell"],[]) "data Both a b = Left a | Right b | Both a b",Header 2 ("primitive-types",[],[]) [Str "Primitive",Space,Str "Types"],Para [Str "We",Space,Str "will",Space,Str "assume",Space,Str "a",Space,Str "few",Space,Str "primitive",Space,Str "types,",Space,Str "for",Space,Str "which",Space,Str "we",Space,Str "do",Space,Str "not",Space,Str "need",Space,Str "to",Space,Str "provide",Space,Str "an",Space,Str "explicit",Space,Str "datatype",Space,Str "definition:"],BulletList [[Plain [Str "Unit",Space,Str "type:",Space,Code ("",[],[]) "()"]],[Plain [Str "Unicode",Space,Str "characters:",Space,Code ("",[],[]) "Char"]],[Plain [Str "Unsigned",Space,Str "integers:",Space,Code ("",[],[]) "Word8",Space,Str "(8",Space,Str "bits),",Space,Code ("",[],[]) "Word16",Str ",",Space,Code ("",[],[]) "Word32",Space,Str "and",Space,Code ("",[],[]) "Word64"]],[Plain [Str "Signed",Space,Str "integers:",Space,Code ("",[],[]) "Int8",Str ",",Space,Code ("",[],[]) "Int16",Str ",",Space,Code ("",[],[]) "Int32",Space,Str "and",Space,Code ("",[],[]) "Int64"]],[Plain [Str "Unlimited",Space,Str "size",Space,Str "signed",Space,Str "Integers:",Space,Code ("",[],[]) "Integer"]],[Plain [Str "Floating",Space,Str "point",Space,Str "numbers:",Space,Code ("",[],[]) "Float16",Str ",",Space,Code ("",[],[]) "Float32",Space,Str "and",Space,Code ("",[],[]) "Float64"]]],Para [Str "We",Space,Str "also",Space,Str "have",Space,Str "the",Space,Str "parametric",Space,Str "types:"],BulletList [[Plain [Str "the",Space,Str "function",Space,Str "type:",Space,Code ("",[],[]) "a -> b"]],[Plain [Str "lists:",Space,Code ("",[],[]) "[a]"]],[Plain [Str "a",Space,Str "whole",Space,Str "family",Space,Str "of",Space,Str "tuple",Space,Str "types",Space,Str "(of",Space,Str "size",Space,Str ">=2):",Space,Code ("",[],[]) "(a,b)",Space,Code ("",[],[]) "(a,b,c)",Space,Code ("",[],[]) "(a,b,c,d)",Space,Str "..."]]],Para [Str "We",Space,Str "will",Space,Str "also",Space,Str "use",Space,Code ("",[],[]) "String",Space,Str "as",Space,Str "a",Space,Str "shorthand",Space,Str "for",Space,Code ("",[],[]) "[Char]",Str "."],Para [Str "We",Space,Str "can",Space,Str "imagine",Space,Str "the",Space,Str "primitive",Space,Str "types",Space,Str "defined",Space,Str "as",Space,Str "follows:"],CodeBlock ("",["haskell"],[]) "data () = ()\n\ndata Char = '\\NUL' ...  | 'a' | 'b' ... | '\\1114111'\n\ndata Word8 = 0 | 1 .. | 255\n\ndata Int8 = -128 | -127 .. | 127\n\ndata Integer = -infinite ... | +infinite\n\ndata Float32 = ... | 0.1 .. | 0.1E+1 ...\n\ndata (->) a b\n\ndata [] a = []\n            | : a ([] a)\n\ndata (,,) a b = (,,) a b\ndata (,,,) a b c = (,,,) a b c\n... infinite??? tuples\n",Para [Str "Finally",Space,Str "the",Space,Str "parametric",Space,Str "IO",Space,Str "type",Space,Str "that",Space,Str "indicates",Space,Str "a",Space,Str "value",Space,Str "that",Space,Str "is",Space,Str "the",Space,Str "result",Space,Str "of",Space,Str "an",Space,Str "interaction",Space,Str "with",Space,Str "the",Space,Str "external",Space,Str "world."],Para [Str "You",Space,Str "can",Space,Str "think",Space,Str "of",Space,Str "an",Space,Code ("",[],[]) "IO a",Space,Str "as",Space,Str "a",Space,Str "pure",Space,Str "function",Space,Str "with",Space,Str "an",Space,Str "additional",Space,Str "hidden",Space,Str "parameter",Space,Str "of",Space,Str "type",Space,Code ("",[],[]) "World",Space,Str "that",Space,Str "indicates",Space,Str "the",Space,Str "current",Space,Str "state",Space,Str "of",Space,Str "the",Space,Str "world",Note [Para [Str "Something",Space,Str "to",Space,Str "ponder",Space,Str "upon",Space,Str "on",Space,Str "a",Space,Str "rainy",Space,Str "day:",Space,Str "if",Space,Str "we",Space,Str "could",Space,Str "capture",Space,Str "the",Space,Str "state",Space,Str "of",Space,Str "the",Space,Str "world",Space,Str "in",Space,Str "a",Space,Str "value,",Space,Str "all",Space,Str "impurity",Space,Str "would",Space,Str "disappear."]],Str ":"],CodeBlock ("",["haskell"],[]) "type IO a = World -> a",Para [Str "There",Space,Str "are",Space,Str "cases",Space,Str "when",Space,Str "we",Space,Str "do",Space,Str "not",Space,Str "expect",Space,Str "a",Space,Str "value",Space,Str "to",Space,Str "be",Space,Str "returned,",Space,Str "these",Space,Str "are",Space,Str "marked",Space,Str "by",Space,Str "the",Space,Str "special",Space,Str "type",Space,Code ("",[],[]) "IOK",Str "."],CodeBlock ("",["haskell"],[]) "type IOK = World -> ()",Para [Str "From",Space,Str "the",Space,Str "point",Space,Str "of",Space,Str "view",Space,Str "of",Space,Str "the",Space,Str "caller,",Space,Str "a",Space,Str "function",Space,Str "of",Space,Str "type",Space,Code ("",[],[]) "IOK",Space,Str "performs",Space,Str "exactly",Space,Str "like",Space,Str "an",Space,Code ("",[],[]) "IO ()",Str "."],Para [Str "From",Space,Str "the",Space,Str "point",Space,Str "of",Space,Str "view",Space,Str "of",Space,Str "the",Space,Str "callee,",Space,Str "the",Space,Str "function",Space,Str "is",Space,Str "received,",Space,Str "its",Space,Str "behaviour",Space,Str "performed",Space,Str "but",Space,Str "nothing",Space,Str "is",Space,Str "returned",Space,Str "back."],Header 3 ("type-judgments-type-checking",[],[]) [Str "Type",Space,Str "Judgments,",Space,Str "type",Space,Str "checking"],Para [Str "Requirements:",Space,Str "*",Space,Str "simple",Space,Str "to",Space,Str "understand",Space,Str "*",Space,Str "simple",Space,Str "to",Space,Str "use",Space,Str "*",Space,Str "efficient",Space,Str "and",Space,Str "simple",Space,Str "to",Space,Str "implement",Space,Str "(even",Space,Str "better",Space,Str "if",Space,Str "typechecking",Space,Str "could",Space,Str "be",Space,Str "subsumed",Space,Str "by",Space,Str "de/serialisation)",Space,Str "*",Space,Str "easy",Space,Str "to",Space,Str "map",Space,Str "to",Space,Str "a",Space,Str "variety",Space,Str "of",Space,Str "existing",Space,Str "languages",Space,Str "(haskell,",Space,Str "js,",Space,Str "java...)",Space,Str "*",Space,Str "support",Space,Str "for",Space,Str "upward",Space,Str "compatibility:",Space,Str "built",Space,Str "in",Space,Str "numeric",Space,Str "subtypes",Space,Str "and,",Space,Str "more",Space,Str "importantly,",Space,Str "data",Space,Str "type",Space,Str "subsets",Space,Str "*",Space,Str "compatible",Space,Str "with",Space,Str "absolute",Space,Str "types",Space,Str "*",Space,Str "support",Space,Str "for",Space,Str "data",Space,Str "types",Space,Str "*",Space,Str "support",Space,Str "for",Space,Str "data",Space,Str "structures:",Space,Str "list,",Space,Str "tuples,",Space,Str "maps.",Space,Str "*",Space,Str "expressive,",Space,Str "open",Space,Str "potential",Space,Str "for",Space,Str "future",Space,Str "expansion",Space,Str "**",Space,Str "support",Space,Str "for",Space,Str "type",Space,Str "classes/interfaces",Space,Str "**",Space,Str "support",Space,Str "for",Space,Str "first",Space,Str "class",Space,Str "modules",Space,Str "**",Space,Str "support",Space,Str "for",Space,Str "first",Space,Str "class",Space,Str "patterns",Space,Str "**",Space,Str "The",Space,Str "concepts",Space,Str "to",Space,Str "unify:",Space,Str "value,",Space,Str "expression,",Space,Str "type,",Space,Str "kind,",Space,Str "sort,",Space,Str "pattern,",Space,Str "class/interface,",Space,Str "module.",Space,Str "**",Space,Str "Pluggable?",Space,Str "As",Space,Str "is",Space,Str "defined",Space,Str "in",Space,Str "the",Space,Str "language",Space,Str "it",Space,Str "can",Space,Str "also",Space,Str "be",Space,Str "changed."],Para [Str "We",Space,Str "need",Space,Str "to",Space,Str "support",Space,Str "multiple",Space,Str "types",Space,Str "for",Space,Str "functions."],Para [Str "The",Space,Str "most",Space,Str "expressive,",Space,Str "though",Space,Str "the",Space,Str "least",Space,Str "constraining",Space,Str "is",Space,Str "a",Space,Str "verbal",Space,Str "description.",Space,Str "It",Space,Str "allows",Space,Str "to",Space,Str "express",Space,Str "anything",Space,Str "but",Space,Str "cannot",Space,Str "be",Space,Str "mechanically",Space,Str "verified."],Para [Str "In",Space,Str "between,",Space,Str "we",Space,Str "have",Space,Str "simple",Space,Str "fully",Space,Str "inferable",Space,Str "type",Space,Str "systems."],Para [Str "Then",Space,Str "we",Space,Str "have",Space,Str "more",Space,Str "sophisticated",Space,Str "but",Space,Str "maybe",Space,Str "only",Space,Str "checkable",Space,Str "type",Space,Str "systems."],Para [Str "General",Space,Str "type",Space,Str "and",Space,Str "subtype",Space,Str "theory:",Space,Str "http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf"],Para [Str "Type",Space,Str "system",Space,Str "design",Space,Str "options:",Space,Str "*",Space,Str "haskell",Space,Str "like:",Space,Str "terms",Space,Str ":",Space,Str "types",Space,Str ":",Space,Str "*",Space,Str "|",Space,Str "*",Space,Str "->",Space,Str "*",Space,Str "full",Space,Str "implementation",Space,Str "of",Space,Str "typechecking",Space,Str "algorythm,",Space,Str "including",Space,Str "typeclasses",Space,Str "in",Space,Str "~/cache/haskell/language/thih-multiparam/",Space,Str "http://web.cecs.pdx.edu/~mpj/thih/thih.pdf"],BulletList [[Plain [Str "pure",Space,Str "subtype",Space,Str "system",Space,Str "best",Space,Str "to",Space,Str "represent",Space,Str "numeric",Space,Str "subtypes",Space,Str "and,",Space,Str "more",Space,Str "importantly,",Space,Str "data",Space,Str "type",Space,Str "subsets",Space,Str "(used",Space,Str "for",Space,Str "upward",Space,Str "compatibility).",Space,Str "??",Space,Str "3.3",Space,Str "controvariance:",Space,Str "can",Space,Str "a",Space,Str "function",Space,Str "on",Space,Str "t",Space,Str "be",Space,Str "applied",Space,Str "to",Space,Str "t1<t",Space,Str "?",Space,Str "if",Space,Str "not",Space,Str "what",Space,Str "is",Space,Str "the",Space,Str "whole",Space,Str "point?"]]],Para [Str "http://redwood.mza.com/~dhutchins/papers/popl10-hutchins.pdf"],BulletList [[Plain [Str "pure",Space,Str "type",Space,Str "systems:",Space,Str "Jan-Willem",Space,Str "Roorda;",Space,Str "Johan",Space,Str "Jeuring.",Space,Str "\"Pure",Space,Str "Type",Space,Str "Systems",Space,Str "for",Space,Str "Functional",Space,Str "Programming\".",Space,Str "Roorda's",Space,Str "masters'",Space,Str "thesis",Space,Str "(linked",Space,Str "from",Space,Str "the",Space,Str "cited",Space,Str "page)",Space,Str "also",Space,Str "contains",Space,Str "a",Space,Str "general",Space,Str "introduction",Space,Str "to",Space,Str "pure",Space,Str "type",Space,Str "systems."]]],Para [Str "Pure",Space,Str "type",Space,Str "system",Space,Str "with",Space,Str "single",Space,Str "term",Space,Str "level",Space,Str "and",Space,Str "data",Space,Str "types",Space,Subscript [Str "/cache/haskell/language/Henk2000/",Space,Str "http://www.staff.science.uu.nl/"],Str "jeuri101/MSc/jwroorda"],BulletList [[Plain [Str "dependent",Space,Str "system:",Space,Str "single",Space,Str "level",Space,Str "with",Space,Str "dependent",Space,Str "types"]]],Para [Str "Simple",Space,Str "implementation",Space,Str "of",Space,Str "dep",Space,Str "type",Space,Str "system",Space,Str "http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf",Space,Str "~/cache/haskell/language/Agda-2.3.2.2/src/prototyping/termrep/lambdapi/"],Para [Str "**",Space,Str "Idris:",Space,Str "practical",Space,Str "haskell-like",Space,Str "dependent",Space,Str "type",Space,Str "language"],Para [Str "**",Space,Str "lambda",Space,Str "aleph",Space,Str "dependent",Space,Str "language",Space,Str "with",Space,Str "single",Space,Str "level",Space,Str "terms,",Space,Str "(sub)types",Space,Str "as",Space,Str "multi-values:",Space,Str "http://www.leafpetersen.com/leaf/publications/dtp2013/lambda-aleph-overview.pdf",Space,Str "Formalisation",Space,Str "of",Space,Str "the",Space,Str "\955\8501",Space,Str "Runtime",Space,Str "http://arxiv.org/pdf/1307.5277v1.pdf"],Para [Str "**",Space,Str "Agda,",Space,Str "total",Space,Str "dependent",Space,Str "language",Space,Str "and",Space,Str "theorem",Space,Str "prover",Space,Str "http://oxij.org/note/BrutalDepTypes/",Space,Str "http://www.cse.chalmers.se/",Subscript [Str "ulfn/papers/afp08/tutorial.pdf",Space,Str "http://www.cse.chalmers.se/"],Str "peterd/papers/DependentTypesAtWork.pdf"],Para [Str "Can",Space,Str "this",Space,Str "be",Space,Str "defined",Space,Str "as",Space,Str "a",Space,Str "type",Space,Str "function?"],Para [Str "--",Space,Str "typeOf",Space,Str "0",Space,Str "=",Space,Str "Word8"],Para [Str "Adding",Space,Str "\8869",Space,Str "to",Space,Str "the",Space,Str "set",Space,Str "of",Space,Str "values",Space,Str "is",Space,Str "also",Space,Str "called",Space,Str "lifting."],Header 3 ("coordination",[],[]) [Str "Coordination"],Para [Str "See",Space,Str "Concurrent",Space,Str "bondi",Space,Str "~/cache/haskell/language/Concurrent",Space,Str "Pattern",Space,Str "Calculus",Space,Str ".pdf"],RawBlock (Format "html") "<!--\n### Subtyping Partial Ordering of Types\n\nSome Types are proper subsets of others:\nWord8 <= Word16 ..<= Word64\nInt8 <= .. <= Int64 <= Integer\nFloat32 <= Float64\n\nIf S is a subtype of T, the subtyping relation is often written S <: T, to mean that any term of type S can be safely used in a context where a term of type T is expected.\n\nIf we thing of types as sets than the subtying relationship coincides with the subset relationship.\n\nDefinitional subtyping:\nDefine a new type as a subset of another\n\n-- Extensional definition\ndata EUCapital = .. Roma | Paris | Berlin | London\n\n-- Scotland leaves the UK and joins the EU as an independent country\ndata EUCapital2014 = = .. Roma | Paris | Berlin | London | Edinburgh\n\n-- The UK leaves the EU\ndata EUCapital2015 = .. Roma | Paris | Berlin | Edinburgh\n\n-- Turkey joins the EU\ndata EUCapital2020 = Roma | Paris | Berlin | London .. | Ankara\n\nA type-constructor C is covariant iff: for all types S,T, if S is a subtype of T then C<S> is a subtype of C<T>.\nSimilarly, for contravariance, if S is a subtype of T then C<T> is a subtype of C<S>. Note that S and T have swapped.\nFunctions are contravariant in the input, but covariant in the output:\nhttp://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\n\ndata A a = A a\ndata B a = B a\ndata C a = C a\ndata AB a b = A a | B b\ndata ABC a b c = A a | B b | C c\n\nf :: ABC -> A\n-- sub functions of this are:\nA|B|C|AB|ABC -> A|AB|ABC\n\n-- Numbers and chars are built in constructors that have to be specified as a range\n-- A data type can be defined as a range\ndata Word8 = 0..255\ndata AlphaChar = 'a' .. 'z'\ndata AsciiChar = `\\00` .. `\\7F`\n\nAlso explicit enumeration?\ndata URLChars = 'a'..'z' | '_'  \n\n-- Not supported: mixing number sets with char sets (?) or normal enumeration \n\n-- Note: chars could also be defined as numbers: \nUnicode defines a codespace of 1,114,112 code points in the range 0hex to 10FFFFhex\ndata Char = 0x0 .. 0x10FFFF \n\n-- Intensional definition (unsupported?)\ndata Evens = \\x::Integer -> x div 2 == 0\n \nSubtyping between built-in numeric/character types.\n\nSubtyping between algebraic types.\n\na) Simple subtyping \na <: b if the constructors of a are identical to  the first constructors of b\n\nb) Flexible subtyping\na <: b if the constructors of a are a subset of the first constructors of b\n\nAs we know the datatype definition we can always establish if a type is a subtype of another and we can use this information to map one onto the other.\n\nThis can be done implicitly or explicitly.\n\nTo support it, we need to pass parameters:\n* with an explicit type signature:\n  * for floats (unless they are expressed as data Rational = Rational Integer Integer)\n  * for flexible algebraic type subtyping\n* or in a common format\n    * for word/ints/chars: easy to implement?\n    * for algebraic types:\n      ** this is already true for simple subtyping\n\nIn haskell, we sidestep the problem by using classes that map types to a common generic representation (e.g. Integer or String) or more in general provide a set of common operations.\n\nConstructors could also be used as common methods so that types that share the same constructors can be applied in the same way (see Elm).\n\nfunctions, including constructors, that accept a type will also automatically accept and convert any subtype (?? this needs a serialisation format that allow us to distinguish ints of different size or a single format for ints of any size).\n\nOr: explicitly defined subtypes using constrains\n\nIsString a => a \n\nclass IsString a where fromString :: String -> a\ninstance IsString Int where fromString = readInt\n\n## Numeric Type Defaults\nIf a type of a number is not specified or deducible by its context is understood to be:\n\n* Float64, if the number is written in scientific format or contains a decimal point\n* Int64 or Integer otherwise\n-->\n",Header 2 ("type-classes",[],[]) [Str "Type",Space,Str "Classes"],Para [Str "http://okmij.org/ftp/Computation/typeclass.html"],Para [Str "using",Space,Str "modules,",Space,Str "3.4.5",Space,Str "3.4.6",Space,Str "and",Space,Str "4.8.1",Space,Str "of",Space,Str "file://localhost/Users/titto/cache/haskell/language/pure%20subtype%20systems%20Hutchins2009.pdf"],Para [Str "http://ropas.snu.ac.kr/~bruno/papers/TypeClasses.pdf"],Para [Str "http://ipaper.googlecode.com/git-history/243b02cb56424d9e3931361122c5aa1c4bdcbbbd/Typeclasses/type-class-explorationi.pdf"],Para [Str "Dynamic",Space,Str "typeclasses:",Space,Str "https://www.fpcomplete.com/user/thoughtpolice/using-reflection"],Header 2 ("pattern-matching",[],[]) [Str "Pattern",Space,Str "matching"],Para [Str "Scala",Space,Str "allows",Space,Str "types",Space,Str "to",Space,Str "be",Space,Str "used",Space,Str "as",Space,Str "patterns",Space,Str "in",Space,Str "pattern",Space,Str "matching",Space,Str "expressions"],Header 2 ("the-values-hierarchy",[],[]) [Str "The",Space,Str "Values",Space,Str "Hierarchy"],Para [Image [Str "Values",Space,Str "Hierarchy"] ("/Users/titto/workspace/quid2-docs/src/Quid2/Doc/valuesHierarchy.pdf","fig:")],Para [Str "Values",Space,Str "are",Space,Str "organised",Space,Str "in",Space,Str "a",Space,Str "hierarchy,",Space,Str "where",Space,Str "higher",Space,Str "levels",Space,Str "organize",Space,Str "the",Space,Str "next",Space,Str "lowest",Space,Str "level."],Para [Str "At",Space,Str "the",Space,Str "lowest",Space,Str "level",Space,Str "we",Space,Str "have",Space,Str "the",Space,Str "values,",Space,Str "neatly",Space,Str "separated",Space,Str "in",Space,Str "sets,",Space,Str "each",Space,Str "labelled",Space,Str "by",Space,Str "a",Space,Str "type."],Para [Str "Types",Space,Str "are",Space,Str "themselves",Space,Str "part",Space,Str "of",Space,Str "a",Space,Str "set:",Space,Str "that",Space,Str "labelled",Space,Str "by",Space,Str "the",Space,Str "catch-all",Space,Str "kind",Space,Code ("",[],[]) "*",Str "."],HorizontalRule,Para [Str "Note",Space,Str "the",Space,Str "similarity",Space,Str "in",Space,Str "the",Space,Str "relationship",Space,Str "between",Space,Str "kind",Space,Str "and",Space,Str "types",Space,Str "and",Space,Str "the",Space,Str "one",Space,Str "between",Space,Str "types",Space,Str "and",Space,Str "values."],Para [Str "In",Space,Str "fact,",Space,Str "we",Space,Str "can",Space,Str "think",Space,Str "of",Space,Str "the",Space,Code ("",[],[]) "*",Space,Str "kind",Space,Str "as",Space,Str "an",Space,Str "higher",Space,Str "level",Space,Str "datatype,",Space,Str "whose",Space,Str "constructors",Space,Str "are",Space,Str "the",Space,Str "types",Space,Str "themselves:"],CodeBlock ("",["haskell"],[]) "kind * = Word8\n       | Maybe *\n       | N\n       ...\n\n-- Or:\n\nopen kind * :: * -- There is an open kind * of sort *\n\nWord8 :: *\n\nMaybe :: * -> *\n\nN :: *",Para [Str "The",Space,Str "main",Space,Str "difference",Space,Str "with",Space,Str "ordinary",Space,Str "datatypes",Space,Str "is",Space,Str "that",Space,Code ("",[],[]) "*",Space,Str "is",Space,Str "open,",Space,Str "every",Space,Str "time",Space,Str "we",Space,Str "define",Space,Str "a",Space,Str "new",Space,Str "datatype",Space,Str "it",Space,Str "gets",Space,Str "an",Space,Str "additional",Space,Str "constructor",Note [Para [Str "Alternatively,",Space,Str "you",Space,Str "can",Space,Str "imagine",Space,Str "that",Space,Str "it",Space,Str "contains",Space,Emph [Str "ab",Space,Str "initio"],Space,Str "all",Space,Str "possible",Space,Str "datatypes."]],Str "."],Para [Str "So",Space,Str "values",Space,Str "are",Space,Str "really",Space,Str "0-level",Space,Str "values",Space,Str "while",Space,Str "types",Space,Str "are",Space,Str "1-level",Space,Str "values,",Space,Str "kinds",Space,Str "are",Space,Str "2-level",Space,Str "values,",Space,Str "sorts",Space,Str "are",Space,Str "3-level",Space,Str "values",Space,Str "and",Space,Str "so",Space,Str "on."],Para [Str "Every",Space,Str "level",Space,Str "defines",Space,Str "a",Space,Str "different",Space,Str "namespace",Space,Str "so,",Space,Str "for",Space,Str "example,",Space,Str "the",Space,Code ("",[],[]) "*",Space,Str "kind",Space,Str "cannot",Space,Str "be",Space,Str "confused",Space,Str "with",Space,Str "the",Space,Code ("",[],[]) "*",Space,Str "sort."],Para [Str "Datatypes",Space,Str "also",Space,Str "have",Space,Str "their",Space,Str "own",Space,Str "namespaces,",Space,Str "same",Space,Str "named",Space,Str "constructors",Space,Str "from",Space,Str "different",Space,Str "datatypes",Space,Str "are",Space,Str "always",Space,Str "distinguishable."],Para [Str "Obviously,",Space,Str "the",Space,Str "hierarchy",Space,Str "continues",Space,Emph [Str "ad",Space,Str "infinitum"],Str ",",Space,Str "but",Space,Str "is",Space,Str "not",Space,Str "a",Space,Str "very",Space,Str "interesting",Space,Str "kind",Space,Str "of",Space,Str "infinity",Space,Str "given",Space,Str "that,",Space,Str "starting",Space,Str "with",Space,Str "the",Space,Str "kind",Space,Str "level,",Space,Str "is",Space,Code ("",[],[]) "*",Space,Str "all",Space,Str "the",Space,Str "way",Space,Str "up",Space,Str "(things",Space,Str "get",Space,Str "a",Space,Str "lot",Space,Str "more",Space,Str "interesting",Space,Str "if",Space,Str "we",Space,Str "start",Space,Str "promoting",Space,Str "lower",Space,Str "level",Space,Str "datatypes",Space,Str "to",Space,Str "higher",Space,Str "levels,",Space,Str "more",Space,Str "on",Space,Str "this",Space,Str "later)."],HorizontalRule,Header 2 ("function-definitions",[],[]) [Str "Function",Space,Str "Definitions"],Para [Str "Functions",Space,Str "are",Space,Str "introduced",Space,Str "by",Space,Str "declarations",Space,Str "of",Space,Str "the",Space,Str "form:"],Para [Str "[",Emph [Str "name"],Space,Code ("",[],[]) "::",Space,Emph [Str "next-higher-level-expression"],Str "]"],Para [Str "[",Code ("",[],[]) "type",Space,Str "|",Space,Code ("",[],[]) "kind",Str "]",Space,Emph [Str "name"],Space,Code ("",[],[]) "=",Space,Emph [Str "expression"]],Para [Str "The",Space,Str "first",Space,Str "line",Space,Str "is",Space,Str "an",Space,Str "optional",Space,Str "type",Space,Str "signature,",Space,Str "it",Space,Str "indicates",Space,Str "the",Space,Str "type",Space,Str "(or",Space,Str "kind",Space,Str "or",Space,Str "sort)",Space,Str "of",Space,Str "the",Space,Str "function.",Space,Str "The",Space,Str "declaration",Space,Str "is",Space,Str "optional",Space,Str "when",Space,Str "the",Space,Str "type",Space,Str "can",Space,Str "be",Space,Str "inferred",Space,Str "by",Space,Str "the",Space,Str "expression",Space,Str "itself."],Para [Str "The",Space,Str "initial",Space,Str "keyword",Space,Str "(",Code ("",[],[]) "type",Space,Str ",",Space,Code ("",[],[]) "kind",Space,Str "or",Space,Str "absent)",Space,Str "indicate",Space,Str "the",Space,Str "level",Space,Str "in",Space,Str "the",Space,Str "type",Space,Str "hierarchy",Space,Str "at",Space,Str "which",Space,Str "the",Space,Str "definition",Space,Str "applies."],Para [Str "If",Space,Str "absent,",Space,Str "the",Space,Str "definition",Space,Str "is",Space,Str "at",Space,Str "the",Space,Str "value",Space,Str "level."],Para [Str "Some",Space,Str "examples:"],CodeBlock ("",["haskell"],[]) "-- Value level definitions\n\n-- No need for a type signature, this is clearly a string\nspeech = \"to be or not to be\"\n\npi :: Float32\npi = 3.1416\n\nprintDoc :: String -> IO ()\nprintDoc name = doc name >>= print . convert\n\n-- Type level definitions\ntype String = [Char]\n\ntype E a = Either a Int ",Header 2 ("qualified-names",[],[]) [Str "Qualified",Space,Str "Names"],Para [Str "It's",Space,Str "convenient",Space,Str "to",Space,Str "organise",Space,Str "our",Space,Str "definitions",Space,Str "in",Space,Str "a",Space,Str "hierarchical",Space,Str "namespace."],Para [Str "We",Space,Str "will",Space,Str "specify",Space,Str "the",Space,Str "namespace",Space,Str "with",Space,Str "the",Space,Str "syntax:"],Para [Code ("",[],[]) "module",Space,Emph [Str "namespace"],Space,Code ("",[],[]) "where"],Para [Str "For",Space,Str "example:"],CodeBlock ("",["haskell"],[]) "module Data where\n\ndata Bool = False | True",Para [Str "defines",Space,Str "the",Space,Str "type",Space,Code ("",[],[]) "Data.Bool",Space,Str "and",Space,Str "the",Space,Str "constructors",Space,Code ("",[],[]) "Data.False",Str ",",Space,Code ("",[],[]) "Data.True",Str "."],CodeBlock ("",["haskell"],[]) "module Math.Constant where\npi = 3.1416",Para [Str "defines",Space,Str "the",Space,Str "function",Space,Code ("",[],[]) "Math.Constant.pi",Str "."],Header 2 ("located-names",[],[]) [Str "Located",Space,Str "Names"],Para [Str "Quid2",Space,Str "is",Space,Str "just",Space,Str "a",Space,Str "coordination",Space,Str "framework,",Space,Str "the",Space,Str "real",Space,Str "functionality",Space,Str "is",Space,Str "provided",Space,Str "at",Space,Str "its",Space,Str "borders",Space,Str "by",Space,Str "service",Space,Str "providers."],Para [Str "Functions",Space,Str "provided",Space,Str "by",Space,Str "service",Space,Str "providers",Space,Str "are",Space,Str "denoted",Space,Str "by",Space,Str "a",Space,Str "naming",Space,Str "scheme",Space,Str "expressed",Space,Str "as",Space,Str "an",Space,Str "ordinary",Space,Str "datatype."],Para [Str "For",Space,Str "example,",Space,Str "the",Space,Str "services",Space,Str "described",Space,Str "in",Space,Str "the",Space,Str "initial",Space,Str "example",Space,Str "might",Space,Str "be",Space,Str "denoted",Space,Str "by",Space,Str "values",Space,Str "of",Space,Str "the",Space,Str "following",Space,Str "type:"],CodeBlock ("",["haskell"],[]) "data SimpleAddr =\n  SimpleAddr\n  String -- Agent where function is located: \"User\" | \"Printer\" ...\n  String -- Function name: \"print\" | \"convert\" ...",Para [Str "Syntactically,",Space,Str "we",Space,Str "write",Space,Str "these",Space,Str "references",Space,Str "as:"],Para [Code ("",[],[]) "<<",Space,Emph [Str "reference"],Space,Code ("",[],[]) ">>"],Para [Str "A",Space,Str "subset",Space,Str "of",Space,Str "the",Space,Str "functions",Space,Str "of",Space,Str "our",Space,Str "example",Space,Str "could",Space,Str "be",Space,Str "expressed",Space,Str "as:"],CodeBlock ("",["haskell"],[]) "module Quid2.Example where\n\nprint :: PDF -> IO ()\nprint = <<SimpleAddr \"Printer\" \"print\">> \n\nconvert :: Doc -> PDF\nconvert = <<SimpleAddr \"Converter\" \"convert\">> \n\ndata PDF = PDF String\n\ndata Doc = Doc String",RawBlock (Format "html") "<!--\n```haskell\nmodule Time where\n\ntype UnixTime = Int64 \n\ncurrentTime :: IO UnixTime\ncurrentTime =  \n\n-- pi, approximated to 4 decimals.\npi :: Float32\npi = 3.1416\n\n-- Infinite list of prime numbers\nprimes :: [Integer]\nprimes = <<SimpleAddr \"Calculator\" \"primes\">> \n\naddW8 :: Word8 -> Word8 -> Word8\n```\n\nDefinitions are represented as:\n-->\n",Header 2 ("formal-definition",[],[]) [Str "Formal",Space,Str "Definition"],Para [Str "The",Space,Str "abstract",Space,Str "syntax",Space,Str "of",Space,Str "Quid2",Space,Str "is",Space,Str "defined",Space,Str "as",Space,Str "follows:"],CodeBlock ("",["haskell"],[]) "-- This is what Quid2 is all about, evaluating expressions.\n-- Evaluation reduces an expression\n-- to the equivalent normal form value.\nevaluation :: Expr n t -> NFValue n t\n\n{- A typed value in normal form.\nThis is the form in which all data\nis ultimately exchanged across Quid2 agents.\nThe presence of a Fun contructor\nis exploited to allow the efficient\nprogressive transfer of data of\npotentially unlimited size (more about this later).\n-}\ndata NFValue n t = \n  -- a function located at some address\n  Fun n         \n  -- an array of bytes, built according to the canonical serialisation\n  | Lit [Word8]\n  -- an error\n  | Err String \n\n-- Absolute declarations, see next section for an explanation.\ntype AbsType = Type AbsName\ntype AbsDecl = DataDecl AbsName\ntype AbsDefinition = Definition AbsName\n\ndata InternalAbsName =\n  -- Reference to a data type in the same recursive group. \n  InternalName QualName\n  -- A declaration in a group of mutually recursive definitions.\n  | ExternalName AbsName \n\ndata AbsName =\n  -- A stand alone declaration\n  AbsName (Ref (DataDecl InternalAbsName))\n  \n  -- A decl in a group of mutually recursive definitions.\n  | AbsNamePart (Ref [DataDecl InternalAbsName]) Word8 \n\n-- A value expression\ntype Value n = Expr (ValueName n) AbsType\n\n-- A type expression\ntype Type name = Expr (TypeName name) () \n\n-- Generic expression. \ndata Expr n t =\n  App (Expr n t) (Expr n t)     -- functional application\n  | Name n                      \n  | Var Variable                -- a variable  \n  | Lambda Variable (Expr n t)  -- a lambda expression\n  | Signature (Expr n t) t      -- an explicit type signature\n\ntype Variable = Word16\n\n-- Value constructors\ndata ValueName n\n    =\n      Function n\n    | Con AbsName Tag  -- data constructor\n    -- Primitive constructors\n    | Tuple Word16  -- (,,) (,,,) ... \n    | ListCons      -- : \n    | ListNil       -- []  \n    | Unit          -- ()\n    | Char Char\n    | Word8 Word8 | Word16 Word16 | Word32 Word32 | Word64 Word64 \n    | Int8 Int8 | Int16 Int16 | Int32 Int32 | Int64 Int64\n    | Float32 Float | Float64 Double\n    | Integer Integer\n\n-- Type constructors\ndata TypeName name\n     = TyDecl name\n     | TypeFun           -- ^ function type \n     | TypeTuple Word16  -- ^ tuple types: example: TypeTuple 3 == (,,) \n     | TypeList          -- ^ list type\n     | TypeIO            -- ^ IO type\n     | TypeUnit\n     | TypeChar\n     | TypeWord8 | TypeWord16 | TypeWord32 | TypeWord64 \n     | TypeInt8 | TypeInt16 | TypeInt32 | TypeInt64\n     | TypeFloat32 | TypeFloat64\n     | TypeInteger\n\n-- Function definition\ndata Definition n t = Definition QualName (Expr n t)\n\n-- Algebraic data declaration\ndata DataDecl name = DataDecl {\n  -- qualified Name\n  ddName::QualName\n  \n  -- number of parametric variables\n  ,ddNumVars::Word8\n\n   -- value constructors in order of definition\n  ,ddCons:: [Cons name]  \n}\n\n-- Constructor declaration\ndata Cons name = Cons Name Tag (Maybe [Name]) (Type name)\n\n-- Position in data type declaration, 0-based. \ntype Tag = Word16 \n\ndata Name\n    = Id String       -- \"a\" \"plus\" \"List\"\n    | Symbol String   -- \"+\" \"()\"\n\ntype ModuleName = String\n\n-- Qualified Name\ndata QualName = QualName ModuleName Name \n\n-- A transferable, compact, reference to an object.\ndata Ref a = Verb [Word8] -- Verbatim serialisation\n           | Hash [Word8] -- SHA-256 hash",Para [Str "The",Space,Str "Quid2",Space,Str "structural",Space,Str "definitions",Space,Str "are",Space,Str "on",Space,Str "purpose",Space,Str "parametric,",Space,Str "allowing",Space,Str "naming",Space,Str "conventions",Space,Str "suitable",Space,Str "for",Space,Str "different",Space,Str "network",Space,Str "environments",Space,Str "(in-process,",Space,Str "local",Space,Str "or",Space,Str "global)",Space,Str "to",Space,Str "be",Space,Str "used."],Header 2 ("absolute-datatypes-and-functional-definitions",[],[]) [Str "Absolute",Space,Str "Datatypes",Space,Str "and",Space,Str "Functional",Space,Str "Definitions"],Para [Str "Quid2",Space,Str "can",Space,Str "be",Space,Str "used",Space,Str "in",Space,Str "many",Space,Str "different",Space,Str "ways:"],BulletList [[Plain [Str "as",Space,Str "a",Space,Str "storage",Space,Str "and",Space,Str "interchange",Space,Str "format"]],[Plain [Str "to",Space,Str "build",Space,Str "distributed",Space,Str "but",Space,Str "local",Space,Str "and",Space,Str "self-contained",Space,Str "systems,",Space,Str "as",Space,Str "the",Space,Str "one",Space,Str "we",Space,Str "briefly",Space,Str "discussed",Space,Str "in",Space,Str "the",Space,Str "introduction"]],[Plain [Str "to",Space,Str "coordinate",Space,Str "independently",Space,Str "developed",Space,Str "Internet",Space,Str "services"]]],Para [Str "To",Space,Str "achieve",Space,Str "the",Space,Str "last",Space,Str "objective,",Space,Str "it",Space,Str "is",Space,Str "necessary",Space,Str "that,",Space,Str "progressively,",Space,Str "service",Space,Str "providers",Space,Str "converge",Space,Str "on",Space,Str "common",Space,Str "or",Space,Str "compatible",Space,Str "data",Space,Str "definitions."],Para [Str "For",Space,Str "example,",Space,Str "to",Space,Str "allow",Space,Str "the",Space,Str "coordination",Space,Str "of",Space,Str "different",Space,Str "flight",Space,Str "reservation",Space,Str "system",Space,Str "a",Space,Str "common",Space,Str "vocabulary",Space,Str "of",Space,Str "concepts",Space,Str "such",Space,Str "as",Space,Str "flight,",Space,Str "ticket,",Space,Str "airport,",Space,Str "departure",Space,Str "and",Space,Str "arrival",Space,Str "time",Space,Str "need",Space,Str "to",Space,Str "be",Space,Str "established."],Para [Str "This",Space,Str "is",Space,Str "similar",Space,Str "to",Space,Str "the",Space,Str "process",Space,Str "by",Space,Str "which",Space,Str "natural",Space,Str "languages",Space,Str "evolve:",Space,Str "new",Space,Str "words",Space,Str "are",Space,Str "added",Space,Str "all",Space,Str "the",Space,Str "time",Space,Str "and",Space,Str "those",Space,Str "that",Space,Str "are",Space,Str "found",Space,Str "useful",Space,Str "are",Space,Str "progressively",Space,Str "adopted."],Para [Str "This",Space,Str "is",Space,Str "a",Space,Str "diffuse,",Space,Str "distributed",Space,Str "process",Space,Str "that",Space,Str "cannot",Space,Str "be",Space,Str "imposed",Space,Str "or",Space,Str "hurried",Space,Str "by",Space,Str "force",Space,Str "or",Space,Str "decree",Space,Str "but",Space,Str "that",Space,Str "can",Space,Str "be",Space,Str "made",Space,Str "smoother",Space,Str "by",Space,Str "providing",Space,Str "a",Space,Str "common",Space,Str "framework",Space,Str "in",Space,Str "which",Space,Str "these",Space,Str "concepts",Space,Str "can",Space,Str "be",Space,Str "expressed."],Para [Str "To",Space,Str "favour",Space,Str "this",Space,Str "process,",Space,Str "Quid2",Space,Str "datatypes",Space,Str "and",Space,Str "functional",Space,Str "definitions",Space,Str "are",Space,Str "denoted",Space,Str "by",Space,Str "globally",Space,Str "unique",Space,Str "identifiers",Space,Str "that",Space,Str "are",Space,Str "deterministically",Space,Str "derived",Space,Str "from",Space,Str "their",Space,Str "structure."],Para [Str "In",Space,Str "other",Space,Str "terms,",Space,Str "datatypes",Space,Str "that",Space,Str "are",Space,Str "structurally",Space,Str "identical,",Space,Str "even",Space,Str "when",Space,Str "developed",Space,Str "independently,",Space,Str "will",Space,Str "end",Space,Str "up",Space,Str "having",Space,Str "the",Space,Str "same",Space,Str "global",Space,Str "identifier",Space,Str "and",Space,Str "therefore",Space,Str "functions",Space,Str "that",Space,Str "use",Space,Str "them",Space,Str "will",Space,Str "be",Space,Emph [Str "ipso",Space,Str "facto"],Space,Str "composable."],Para [Str "Absolute",Space,Str "datatypes",Space,Str "references",Space,Str "are",Space,Str "build",Space,Str "with",Space,Str "the",Space,Str "following",Space,Str "algorithm:"],BulletList [[Plain [Str "Split",Space,Str "the",Space,Str "type",Space,Str "graph",Space,Str "in",Space,Str "sets",Space,Str "of",Space,Str "strongly",Space,Str "connected",Space,Str "types",Space,Str "(sets",Space,Str "of",Space,Str "mutually",Space,Str "recursive",Space,Str "datatypes)."]],[Plain [Str "For",Space,Str "each",Space,Str "set:"],BulletList [[Plain [Str "Transform",Space,Str "the",Space,Str "set",Space,Str "to",Space,Str "its",Space,Str "canonical",Space,Str "form:"],BulletList [[Plain [Str "Sort",Space,Str "datatypes",Space,Str "declarations",Space,Str "lexicographically"]],[Plain [Str "For",Space,Str "each",Space,Str "datatype:"],BulletList [[Plain [Str "Normalise",Space,Str "variables"]],[Plain [Str "Convert",Space,Str "external",Space,Str "references",Space,Str "to",Space,Str "absolute",Space,Str "references"]],[Plain [Str "Serialise",Space,Str "the",Space,Str "dataset",Space,Str "value",Space,Str "and",Space,Str "calculate",Space,Str "a",Space,Str "unique",Space,Str "hash",Space,Str "value"]]]]]]]]],Para [Str "There",Space,Str "are",Space,Str "many",Space,Str "ways",Space,Str "in",Space,Str "which",Space,Str "structural",Space,Str "equivalence",Space,Str "can",Space,Str "be",Space,Str "defined."],Para [Str "In",Space,Str "Quid2,",Space,Str "two",Space,Str "datatypes",Space,Str "are",Space,Str "considered",Space,Str "equivalent",Space,Str "only",Space,Str "if:"],BulletList [[Plain [Str "the",Space,Str "fully",Space,Str "qualified",Space,Str "names",Space,Str "of",Space,Str "their",Space,Str "type",Space,Str "constructors",Space,Str "are",Space,Str "identical"]],[Plain [Str "their",Space,Str "normalised",Space,Str "parametric",Space,Str "parameters",Space,Str "are",Space,Str "identical"]],[Plain [Str "their",Space,Str "value",Space,Str "constructors",Space,Str "are",Space,Str "also",Space,Str "identical"]]],Para [Str "Both",Space,Str "standalone",Space,Str "and",Space,Str "mutually",Space,Str "recursive",Space,Str "sets",Space,Str "of",Space,Str "datatypes",Space,Str "are",Space,Str "supported."],Para [Str "Consider",Space,Str "the",Space,Str "two",Space,Str "declarations:"],CodeBlock ("",["haskell"],[]) "data Maybe b = Nothing | Just b\n\ndata Maybe c = Nothing | Just c",Para [Str "Maybe",Space,Str "does",Space,Str "not",Space,Str "explicitly",Space,Str "refer",Space,Str "to",Space,Str "any",Space,Str "other",Space,Str "type."],Para [Str "So",Space,Str "the",Space,Str "only",Space,Str "thing",Space,Str "we",Space,Str "need",Space,Str "to",Space,Str "do",Space,Str "is",Space,Str "to",Space,Str "normalise",Space,Str "the",Space,Str "variable",Space,Str "names",Space,Str "transforming",Space,Str "both",Space,Str "of",Space,Str "them",Space,Str "to:"],CodeBlock ("",["haskell"],[]) "data Maybe a = Nothing | Just a",Para [Str "Their",Space,Str "global",Space,Str "id",Space,Str "will",Space,Str "therefore",Space,Str "be",Space,Str "the",Space,Str "same."],Para [Str "In",Space,Str "contrast",Space,Str "the",Space,Str "two",Space,Str "declarations:"],CodeBlock ("",["haskell"],[]) "data Maybe b = Just b | Nothing \n\ndata Maybe c = Nothing | Just c",Para [Str "won't",Space,Str "match",Space,Str "as",Space,Str "the",Space,Str "constructor",Space,Str "ordering",Space,Str "differs."],Para [Str "A",Space,Str "looser",Space,Str "concept",Space,Str "of",Space,Str "structural",Space,Str "equivalence",Space,Str "is",Space,Str "possible",Space,Str "and",Space,Str "might",Space,Str "be",Space,Str "useful",Space,Str "in",Space,Str "certain",Space,Str "cases,",Space,Str "it",Space,Str "however",Space,Str "increases",Space,Str "the",Space,Str "risk",Space,Str "of",Space,Str "mismatches",Space,Str "(what",Space,Str "would",Space,Str "be",Space,Str "called",Space,Emph [Str "false",Space,Str "friends"],Space,Str "in",Space,Str "natural",Space,Str "languages)."],Para [Str "Functional",Space,Str "definitions",Space,Str "are",Space,Str "similarly",Space,Str "denoted",Space,Str "by",Space,Str "globally",Space,Str "unique",Space,Str "identifiers",Space,Str "deterministically",Space,Str "derived",Space,Str "from",Space,Str "their",Space,Str "structure."],RawBlock (Format "html") "<!--\n## Expressions\n\nStrict or Lazy evaluation? Or should it be customisable as in Haskell?\n\n## Expressions Evaluation\n\nThere are many different ways of defining expressions, we start with a really simple one.\n\n\nRemote Values browsing and retrieval requirements:\n-- Present values intelligibly to the user (Meaningful name, type, indication of provider?, possibly also associated comments) (this is the answer to the question: Why should I retrieve this value?)\n   Data.Math by Titto\n      -- The pi constant, approximated to 2 decimals.\n      pi :: Double\n      pi = 3.14\n\n-- Distinguish between different values, provided by the same or different providers.\n\n-- Retrieve values: finite values, infinite values and services (IO values, streams) that take parameters (How should I retrieve this?)\n   data Ref n a = Verb [Word8] | Ref n\n\n-- Long term retrieval of large values?\n\n-- Shareable names: names are not user or session specific. \n\nComponents of a value:\n- absolute definition: the canonical serialisation of: QualName+Value (+AbsType?) \n\n- declaration: name+absType (a, possibly duplicate, identifier, meant\nto express what the thing is, example: Math.pi)\n\n  isn't a name also a unique reference in a given contest?\n\nA value is any value definable via the type system.\n\nA definition:\n\n- (abs)Type: the set of which the value is a member, needed to decode\n  the value. The context into which the value is to be understood.\n\n- reference/address/endpoint (a unique, stable?, executable way to retrieve a value)\n\n- value/extension (the calculated, possibly infinite, value)\n  can also be considered as a simplified intension that includes only\n  actual values and names that point to the remaining parts of the\n  value.\n\n- self-describing value: value+absType\n\n- intension/implementation (the definition of the value)\n\nIn WWW:\nName==Address==URL http:://example.com/one, the name often includes a\ntype (index[.html])\nhttp:://haskell.org/haskellManual.pdf\nAddress: http:://haskell.org/haskellManual.pdf\nName:haskellManual\nType:pdf\nIntension: The hidden implementation (e.g. a server script)\nextension: The returned page via HTTP.\ntype: the MIME type, also retrieved dynamically \n\nIn Haskell:\nName:: <package>QualName\n\nThe simplest kind of value is a finite array of bytes.\nThe data Ref a = Hash .. | Verb .. type is an appropriate ref for this kind of value.\n\nVerb [1] :: Ref Word8\n\nThis is all that is required to retrieve the value 1::Word8\n\nwhere Hash is calculated on the base of the value (how if it is infinite?)\n\nAlgorithm to produce a Definition:\n\nFor the expression:\n-- if it is a pure value, decode it up to a maximum size.\n\n   If the encoded result is Complete, we can build a complete and publisher-independent definition: Literal [serialization]\n\n   In all other cases:\n   We produce a stable local short hash, for example a MD5 of\n   f(QualName,Type+possibly a version name) and returns a: Func (Via\n   (RPC \"my.server\" \"my.port\") (At MD5))\n\n-- Now we have a unique definition.\n\n-- ?? To refer to this definition, we can use its Hash.\n   The final obtains Data.Math.pi.Verb_0314\n\nWe assume that function ns with same type are always the same, if you\nwant another version you have to change name.\n\ndata Serialized k = Complete B.ByteString -- Small Pure Value\n                  | Approx B.ByteString k -- Holed value with\ncontinuation (Pos -> IO a)\n\nEvery name has the form Module.Name.Hash\nData.Math.pi.Hash_1234\n-->\n\n<!--\n<h3>Classes</h3>\nCan classes be simulated (but without automatic derivation of instances)?\n\nWe need at least: named fields (not really), functions as values.\n\ntt = double wordDict 3\n\ndata NumDict a = NumDict {plus :: a -> a -> a}\n\n-- Num a => double :: a -> a -> a\ndouble :: NumDict a -> a -> a\ndouble numDict a = plus numDict a a \n\n-- hand made instance/dictionary\nwordDict = NumDict {plus=(+)}\n  \n-->\n\n<!--\n### Errors and Error Handling\n\nSince Haskell is a non-strict language, all Haskell types include bottom. \n\nThat is, a value of any type may be bound to a computation that, when demanded, results in an error. When evaluated, errors cause immediate program termination and cannot be caught by the user.\n\nErrors in Haskell are semantically equivalent to bottom. Technically, they are not distinguishable from nontermination.\n\nThe Prelude provides two functions to directly cause such errors:\nerror :: String -> a undefined :: a\n\n### Caching \n\nShould a IO a be considered as equivalent to: World a? -> a ?? Would this give as more flexibility? How to distinguish pure/impure functions?\n\n\n### Coding of Large (in either Time or Space) or Infinite Values\n\nIt might seem that is useful for recursive data types that can be arbitrary long, but it can also be useful for fixed size values that are expensive to compute.\n\nRequirements:\n\n* Lazily access large/infinite method results and parameters on client/server side.\n* No significant time/space overhead for using non-infinite values.\n* Fairness: Structures (lists, tuples, normal constructors) with multiple infinite substructure can be expanded independently.\n\nValues are returned as expandable approximation (an approx is a lesser value).\n\nOr values are returned as an expression that is not in normal form.\n\nAn approximation is a structure where holes are marked with a unique Hole constructor.\n\nPrior to serialising, we transform all datatypes from:\n\n```haskell\ndata Maybe a = Just a | Nothing\n\n\ndata Tree a = Leaf a | Tree (Tree a) (Tree a) \n```\n\nto:\n\n```haskell\ndata Maybe a f = Just a | Nothing | Hole (Expr f)\n\ndata Tree a f = Leaf a | Tree (Tree a) (Tree a) | Hole (Expr f)\n```\n\nIf `f == ()` the serialisation of `D f` will be identical to that of `D`.\n\nOtherwise, we now have a way of replacing a value with an expression. \n\nor \n\n```haskell\ndata Maybe a = Just a | Nothing | Hole H -- where H is the protocol parameter\n```\n\n#### Persistent Unevaluated Values\n\nTypically the functions For large constants: persistency, the holes left in the structure can be opened at any later time.\n-->\n \n",Header 1 ("protocol",[],[]) [Str "Protocol"],Para [Str "In",Space,Str "Quid2,",Space,Str "communication",Space,Str "takes",Space,Str "place",Space,Str "between",Space,Str "endpoints:"],BulletList [[Plain [Str "bound",Space,Str "to",Space,Str "a",Space,Str "specific",Space,Str "identity"]],[Plain [Str "addressed",Space,Str "via",Space,Str "a",Space,Str "local",Space,Str "or",Space,Str "global",Space,Str "addressing",Space,Str "scheme"]],[Plain [Str "connected",Space,Str "via",Space,Str "uni-directional",Space,Str "typed",Space,Str "channels"]]],Header 2 ("identity",[],[]) [Str "Identity"],Para [Str "Identity",Space,Str "is",Space,Str "defined",Space,Str "as",Space,Str "the",Space,Str "provable",Space,Str "control",Space,Str "of",Space,Str "an",Space,Str "end",Space,Str "point."],Para [Str "A",Space,Str "datatype",Space,Str "that",Space,Str "captures",Space,Str "some",Space,Str "of",Space,Str "the",Space,Str "many",Space,Str "possible",Space,Str "identities:"],CodeBlock ("",["haskell"],[]) "data Identity = Anonymous\n        | OpenID String\n        | Email String    \n        | Facebook String ",Header 2 ("addressing-schemes",[],[]) [Str "Addressing",Space,Str "Schemes"],Para [Str "As",Space,Str "discussed",Space,Str "previously,",Space,Str "Quid2",Space,Str "doesn't",Space,Str "impose",Space,Str "a",Space,Str "particular",Space,Str "addressing",Space,Str "system",Space,Str "as",Space,Str "different",Space,Str "ones",Space,Str "might",Space,Str "be",Space,Str "suitable",Space,Str "for",Space,Str "different",Space,Str "network",Space,Str "environments."],Para [Str "For",Space,Str "Internet",Space,Str "wide",Space,Str "services,",Space,Str "the",Space,Str "use",Space,Str "of",Space,Str "the",Space,Str "following",Space,Str "datatype",Space,Str "is",Space,Str "however",Space,Str "advised:"],CodeBlock ("",["haskell"],[]) "module Network where\n\n-- An Internet endpoint address\ndata Route =\n  -- A route that goes through an intermediary (e.g. a proxy or a router)       \n  Via   \n  Route -- care taker, gateway, \n  Route -- final destination\n           \n  | Local String -- Local address\n\n  | IP IPAddress -- Internet address\n\ndata IPAddress = IPAddress Host Port   \n\n-- -- Either an IP or symbolic domain: e.g. \"127.0.0.1\" or \"example.org\" \ntype Host = String \n\n-- e.g. 8080\ntype Port = Word32 ",Para [Str "Example:"],CodeBlock ("",["haskell"],[]) "-- ring a bell at example.org, reached via quid2.org:8080 and local port 1234.\nringABell :: IO ()\nringABell = <<Via (IP \"quid2.org\" 8080)\n            (Via (IP \"example.org\" 1234) (Local \"bell\"))>>",Header 2 ("channels",[],[]) [Str "Channels"],Para [Str "A",Space,Str "typed",Space,Str "channel",Space,Str "can",Space,Str "transfer",Space,Str "an",Space,Str "unlimited",Space,Str "number",Space,Str "of",Space,Str "values",Space,Str "of",Space,Str "its",Space,Str "type."],Para [Str "Contrary",Space,Str "to",Space,Str "usual",Space,Str "network",Space,Str "protocols,",Space,Str "there",Space,Str "is",Space,Str "no",Space,Str "need",Space,Str "for",Space,Str "extensive",Space,Emph [Str "in-protocol"],Space,Str "negotiation",Space,Str "of",Space,Str "protocol",Space,Str "parameters",Space,Str "such",Space,Str "as",Space,Str "versions,",Space,Str "format,",Space,Str "compression,",Space,Str "timeouts",Space,Str "or",Space,Str "quality",Space,Str "of",Space,Str "service."],Para [Str "Assuming",Space,Str "that",Space,Str "every",Space,Str "agent",Space,Str "has",Space,Str "a",Space,Str "bootstrap",Space,Str "channel",Space,Str "of",Space,Str "known",Space,Str "type",Space,Str "to",Space,Str "start",Space,Str "its",Space,Str "interaction",Space,Str "with",Space,Str "the",Space,Str "Quid2",Space,Str "system,",Space,Str "further",Space,Str "channel",Space,Str "references",Space,Str "should",Space,Str "be",Space,Str "obtained",Space,Str "by",Space,Str "functions",Space,Str "that",Space,Str "take",Space,Str "care",Space,Str "of",Space,Str "all",Space,Str "these",Space,Str "aspects,",Space,Str "escaping",Space,Str "the",Space,Str "limits",Space,Str "of",Space,Str "hard",Space,Str "wired",Space,Str "network",Space,Str "protocols."],Para [Str "Each",Space,Str "channel",Space,Str "has",Space,Str "an",Space,Str "associated",Space,Str "identity",Space,Str "(the",Space,Str "identity",Space,Str "of",Space,Str "the",Space,Str "peer",Space,Str "with",Space,Str "which",Space,Str "we",Space,Str "are",Space,Str "communicating)."],Para [Str "Channels",Space,Str "come",Space,Str "in",Space,Str "all",Space,Str "kind",Space,Str "of",Space,Str "flavours,",Space,Str "some",Space,Str "examples",Space,Str "follow."],CodeBlock ("",["haskell"],[]) "-- A proxy used by web clients, on either HTTP or HTTPS\n-- with optional compression.\ndata HttpChannel a framing = HttpChannel IP Secure framing\n\ntype Secure = Bool\n\n-- Some examples of framings\ndata WebRPC\n\ndata NoCompression = NoCompression\ndata GZIPCompression = GZIPCompression\ndata SnappyCompression = SnappyCompression\n\n-- A TCP channel\n\ndata TCPChannel a = TCPChannel IP\n\n-- A Local, in-process channel\ndata LocalChannel a = LocalChannel Word64 -- channel identifier.\n\n-- Some channels might be constrained to transfer only a certain type of values\n-- This will only transfer strings coded according to Twitter's standards.\ndata TwitterChannel = TwitterChannel String -- channel identifier",Para [Str "Some",Space,Str "example",Space,Str "channels:"],CodeBlock ("",["haskell"],[]) "-- A stream of IBM's market prices\nibmQuotes :: TCPChannel Float32\nibmQuotes = TCPChannel (IP \"quotes.ibm.com\" 1234)\n\n-- A channel to a local Quid2-aware printer\n-- that is able to interpret simple expressions.\nmyPrinter :: TCPChannel (Expr String)\nmyPrinter = TCPChannel (IP \"192.168.1.4\" 4444)",RawBlock (Format "html") "<!--\nAll types of channels should satisfy the following requirements:\n\nIt is possible but not required to specify authentication details/timeouts/preferred origin of value.\n<ul>\n  <li>Generic API, implementable on top of multiple transports: (local\n  channels,sockets,HTTP/HTTPS) with support for open connection to a\n  remote endpoint and transferring arbitrary? length bytestrings</li>\n  <li>Efficient communication (fast throughput, low latency)</li>\n   <li>Fair use?: large calls that transfer large quantity of data cannot\n  excessively slow down other calls (this should be taken care by\n  limiting the max size of messages, another reason to support holes)</li> \n  <li>Reuse authentication provided by protocol.</li>\n</ul>\n\n<h3>Application/Route/Stream Level</h3>\n\nRequirements:\n<ul>\n  <li>Communication takes place between endpoints (uniquely addressable (by\n  IP/port/protocol)</li>\n  <li>Establish unique persistent (automatically created and\n  recreated?) communication links among different\n  nodes, that are shared by different calls/evaluations, on which\n  values of a certain kind (e.g. messages) flow freely in both directions.</li>\n  <li>Fair use: calls that transfer large quantity of data cannot\n  excessively slow down other calls (this should be taken care by\n  limiting the max size of messages, another reason to support holes)</li>\n  <li>Support for proxies that act on behalf of other clients</li>\n  <li>Upward compatibility: new servers can support\n  additional protocols</li>\n  <li>Downward compatibility: older clients can still get serviced</li>\n </ul>\n\nCommunication takes place between couples of EndPoints.\n\nAn EndPoint is an Identity (why?) +Route, like an email:\ntitto@kamus.it [|| An endpoint is just a Route]]\n\nProtocol implementation:\nhttp://www.pubnub.com/blog/what-is-webrtc/\n\n-->\n \n",Header 1 ("serialisation",[],[]) [Str "Serialisation"],Para [Str "Serialisation",Space,Str "is",Space,Str "the",Space,Str "process",Space,Str "by",Space,Str "which",Space,Str "a",Space,Str "Quid2",Space,Str "value",Space,Str "is",Space,Str "encoded",Space,Str "into",Space,Str "a",Space,Str "concrete",Space,Str "binary",Space,Str "representation,",Space,Str "transferred",Space,Str "over",Space,Str "a",Space,Str "network",Space,Str "of",Space,Str "stored",Space,Str "locally,",Space,Str "and",Space,Str "then",Space,Str "decoded",Space,Str "to",Space,Str "an",Space,Str "equivalent",Space,Str "value."],Para [Str "The",Space,Str "stages",Space,Str "of",Space,Str "the",Space,Str "serialisation",Space,Str "process:"],BulletList [[Para [Str "Canonicalisation:",Space,Str "data",Space,Str "value",Space,Str "is",Space,Str "converted",Space,Str "into",Space,Str "a",Space,Str "canonical",Space,Str "form."]],[Para [Str "Encoding:",Space,Str "the",Space,Str "data",Space,Str "value",Space,Str "is",Space,Str "encoded",Space,Str "into",Space,Str "a",Space,Str "byte",Space,Str "stream."]],[Para [Str "Framing:",Space,Str "data",Space,Str "is",Space,Str "framed",Space,Str "according",Space,Str "to",Space,Str "the",Space,Str "rules",Space,Str "of",Space,Str "the",Space,Str "underlaying",Space,Str "communication",Space,Str "protocol",Space,Str "(e.g.",Space,Str "if",Space,Str "data",Space,Str "is",Space,Str "to",Space,Str "be",Space,Str "stored",Space,Str "locally",Space,Str "is",Space,Str "written",Space,Str "to",Space,Str "a",Space,Str "file,",Space,Str "or",Space,Str "if",Space,Str "transferred",Space,Str "via",Space,Str "HTTP",Space,Str "is",Space,Str "framed",Space,Str "as",Space,Str "an",Space,Str "HTTP",Space,Str "request).",Space,Str "Data",Space,Str "compression",Space,Str "is",Space,Str "an",Space,Str "optional",Space,Str "sub-stage",Space,Str "of",Space,Str "framing."]],[Para [Str "Unframing:",Space,Str "data",Space,Str "is",Space,Str "unframed",Space,Str "(and",Space,Str "possibly",Space,Str "uncompressed)."]],[Para [Str "Decoding"]]],CodeBlock ("",["haskell"],[]) "module Network.Serialise where\n\n-- A value of type `a`, encoded as specified by `encoding`.\ndata Encoded a encoding = Encoded [Word8]\n\n-- The canonical encoding.\ndata CanonicalEncoding = CanonicalEncoding\n\nprimitive encode :: a -> Encoded a CanonicalEncoding\nprimitive decode :: Encoded a CanonicalEncoding -> Either String a",Para [Str "Requirements:"],BulletList [[Para [Str "Support",Space,Str "for",Space,Str "all",Space,Str "definable",Space,Str "data",Space,Str "types",Space,Str "(including",Space,Str "function",Space,Str "types)."]],[Para [Str "Support",Space,Str "for",Space,Str "expressions",Space,Str "and",Space,Str "infinite",Space,Str "data",Space,Str "structures."]],[Para [Str "Support",Space,Str "for",Space,Str "undefined",Space,Str "values",Space,Str "and",Space,Str "errors."]],[Para [Str "Support",Space,Str "for",Space,Str "basic",Space,Str "data",Space,Str "structures",Space,Str "(tuples,",Space,Str "lists",Space,Str "and",Space,Str "maps)."]],[Para [Str "Support",Space,Str "for",Space,Str "unsigned",Space,Str "and",Space,Str "signed",Space,Str "numeric",Space,Str "types."]],[Para [Str "Support",Space,Str "for",Space,Str "infinite",Space,Str "precision",Space,Str "integers."]],[Para [Str "Upward",Space,Str "compatibility",Space,Str "for",Space,Str "unsigned",Space,Str "and",Space,Str "signed",Space,Str "numeric",Space,Str "types:",Space,Str "numeric",Space,Str "types",Space,Str "of",Space,Str "lower",Space,Str "precision",Space,Str "can",Space,Str "be",Space,Str "decoded",Space,Str "as",Space,Str "higher",Space,Str "precision",Space,Str "types",Space,Str "(for",Space,Str "example:",Space,Str "an",Space,Str "Int8",Space,Str "can",Space,Str "be",Space,Str "read",Space,Str "as",Space,Str "an",Space,Str "Int16,",Space,Str "however",Space,Str "a",Space,Str "Word8",Space,Str "cannot",Space,Str "be",Space,Str "read",Space,Str "in",Space,Str "as",Space,Str "an",Space,Str "Int16!)."]],[Para [Str "Support",Space,Str "for",Space,Str "IEEE",Space,Str "754",Space,Str "floats."]],[Para [Str "Support",Space,Str "for",Space,Str "infinite",Space,Str "precision",Space,Str "floats."]],[Para [Str "Easy",Space,Str "and",Space,Str "fast",Space,Str "to",Space,Str "decode."]],[Para [Str "Compact",Space,Str "data",Space,Str "representation",Space,Str "(competitive",Space,Str "with",Space,Str "existing",Space,Str "standard",Space,Str "such",Space,Str "as",Space,Str "rfc7049)."]]],Para [Str "Non",Space,Str "requirements:"],BulletList [[Para [Str "Self-describing",Space,Str "format:",Space,Str "unnecessary",Space,Str "as",Space,Str "communication",Space,Str "is",Space,Str "expected",Space,Str "to",Space,Str "take",Space,Str "place",Space,Str "on",Space,Str "typed",Space,Str "channels(dynamically",Space,Str "typed",Space,Str "values",Space,Str "can",Space,Str "also",Space,Str "be",Space,Str "transferred",Space,Str "using",Space,Str "Typed",Space,Str "values)."]],[Para [Str "Human",Space,Str "readable",Space,Str "(though",Space,Str "is",Space,Str "convenient",Space,Str "to",Space,Str "be",Space,Str "able",Space,Str "to",Space,Str "read",Space,Str "at",Space,Str "least",Space,Str "small",Space,Str "unsigned",Space,Str "integers)"]],[Plain [Str "Encoding",Space,Str "efficiency,",Space,Str "not",Space,Str "very",Space,Str "important",Space,Str "compared",Space,Str "with",Space,Str "decoding",Space,Str "efficiency",Space,Str "as:"],BulletList [[Plain [Str "For",Space,Str "every",Space,Str "encoding",Space,Str "operation",Space,Str "there",Space,Str "are",Space,Str "1..N",Space,Str "decoding",Space,Str "operations."]],[Plain [Str "Static",Space,Str "values",Space,Str "can",Space,Str "often",Space,Str "be",Space,Str "encoded",Space,Str "offline",Space,Str "and",Space,Str "the",Space,Str "result",Space,Str "cached."]],[Plain [Str "The",Space,Str "time",Space,Str "needed",Space,Str "to",Space,Str "dynamically",Space,Str "generated",Space,Str "a",Space,Str "value",Space,Str "is",Space,Str "likely",Space,Str "to",Space,Str "dominate",Space,Str "the",Space,Str "time",Space,Str "taken",Space,Str "to",Space,Str "encode",Space,Str "it."]]]],[Para [Str "High",Space,Str "compression:",Space,Str "this",Space,Str "is",Space,Str "better",Space,Str "provided",Space,Str "by",Space,Str "a",Space,Str "separate",Space,Str "compression",Space,Str "stage."]]],Header 2 ("canonical-implementation",[],[]) [Str "Canonical",Space,Str "Implementation"],Para [Str "Encoding",Space,Str "is",Space,Str "byte-aligned:",Space,Str "an",Space,Str "encoding",Space,Str "is",Space,Str "a,",Space,Str "possibly",Space,Str "empty,",Space,Str "sequence",Space,Str "of",Space,Str "bytes."],Para [Str "An",Space,Str "encoded",Space,Str "value",Space,Str "is",Space,Str "not",Space,Str "self-describing,",Space,Str "we",Space,Str "need",Space,Str "to",Space,Str "know",Space,Str "its",Space,Str "type",Space,Str "to",Space,Str "decode",Space,Str "it."],Para [Str "In",Space,Str "this",Space,Str "section,",Space,Str "we",Space,Str "will",Space,Str "use",Space,Str "the",Space,Str "symbol",Space,Str "->",Space,Str "to",Space,Str "indicated",Space,Str "encoding."],Para [Str "So",Space,Str "'a",Space,Str "->",Space,Str "[97]'",Space,Str "means",Space,Str "that",Space,Str "the",Space,Str "characted",Space,Str "'a'",Space,Str "is",Space,Str "encoded",Space,Str "as",Space,Str "the",Space,Str "bytes",Space,Str "sequence",Space,Str "'[97]'."],Header 2 ("coding-of-data-types",[],[]) [Str "Coding",Space,Str "of",Space,Str "Data",Space,Str "Types"],Para [Str "As",Space,Str "we",Space,Str "have",Space,Str "seen,",Space,Str "data",Space,Str "types",Space,Str "are",Space,Str "defined",Space,Str "as",Space,Str "a",Space,Str "sum",Space,Str "of",Space,Str "constructors",Space,Str "and",Space,Str "every",Space,Str "constructor",Space,Str "is",Space,Str "a",Space,Str "named",Space,Str "product",Space,Str "of",Space,Str "values."],Para [Str "Every",Space,Str "constructor",Space,Str "is",Space,Str "uniquely",Space,Str "identified",Space,Str "by",Space,Str "its",Space,Str "tag",Space,Str "(that",Space,Str "correspond",Space,Str "to",Space,Str "its",Space,Str "1-based",Space,Str "position",Space,Str "in",Space,Str "the",Space,Str "data",Space,Str "type",Space,Str "declaration)."],Para [Str "The",Space,Str "tag",Space,Str "has",Space,Str "type",Space,Code ("",[],[]) "Word16",Space,Str "so",Space,Str "a",Space,Str "datatype",Space,Str "can",Space,Str "have",Space,Str "up",Space,Str "to",Space,Str "65535",Space,Str "constructors."],Para [Str "A",Space,Str "value",Space,Str "created",Space,Str "by",Space,Str "a",Space,Str "given",Space,Str "constructor",Space,Str "is",Space,Str "encoded",Space,Str "as",Space,Str "the",Space,Str "concatenation",Space,Str "of",Space,Str "its",Space,Str "constructor",Space,Str "tag",Space,Str "and",Space,Str "of",Space,Str "the",Space,Str "encodings",Space,Str "of",Space,Str "all",Space,Str "its",Space,Str "components."],Para [Str "If",Space,Str "the",Space,Str "type",Space,Str "has",Space,Str "a",Space,Str "single",Space,Str "constructor,",Space,Str "the",Space,Str "tag",Space,Str "is",Space,Str "omitted."],Para [Str "For",Space,Str "example,",Space,Str "the",Space,Str "single",Space,Str "constructor",Space,Str "type",Space,Str "()",Space,Str "is",Space,Str "encoded",Space,Str "as",Space,Str "an",Space,Str "empty",Space,Str "byte",Space,Str "sequence:"],CodeBlock ("",[],[]) "() -> [] ",RawBlock (Format "html") "<!--\nConsider the single constructor type (there are many single constructor types, the () and all tuples):\n\n```haskell\ndata AnInt = AnInt Int32\n```\n-->\n",Para [Str "Consider",Space,Str "the",Space,Str "parametric",Space,Str "type:"],CodeBlock ("",["haskell"],[]) "data Maybe a = Nothing | Just a",Para [Str "It",Space,Str "has",Space,Str "two",Space,Str "constructors:",Space,Code ("",[],[]) "Nothing",Space,Str "that",Space,Str "has",Space,Str "a",Space,Str "tag",Space,Str "of",Space,Str "1",Space,Str "and",Space,Code ("",[],[]) "Just",Space,Str "that",Space,Str "has",Space,Str "a",Space,Str "tag",Space,Str "of",Space,Str "2."],Para [Str "The",Space,Str "encoding",Space,Str "of",Space,Str "a",Space,Code ("",[],[]) "Nothing",Space,Str "value",Space,Str "is",Space,Str "simply",Space,Str "its",Space,Str "tag,",Space,Str "the",Space,Str "encoding",Space,Str "of",Space,Str "a",Space,Code ("",[],[]) "Just a",Space,Str "is",Space,Str "its",Space,Str "tag",Space,Str "followed",Space,Str "by",Space,Str "the",Space,Str "encoding",Space,Str "of",Space,Str "the",Space,Str "'a'."],Para [Str "For",Space,Str "example:"],CodeBlock ("",[],[]) "(Nothing::Maybe Char) -> [1] ",Para [Str "and:"],CodeBlock ("",[],[]) "(Just 'z'::Maybe Char) -> [2,122] ",Para [Str "Data",Space,Str "types",Space,Str "that",Space,Str "have",Space,Str "no",Space,Str "constructors",Space,Str "obviously",Space,Str "cannot",Space,Str "be",Space,Str "serialized:"],CodeBlock ("",["haskell"],[]) "data Void",RawBlock (Format "html") "<!--\nCoding of Functions\n\n???\n-->\n",Header 2 ("coding-of-tuples",[],[]) [Str "Coding",Space,Str "of",Space,Str "Tuples"],Para [Str "The",Space,Str "encoding",Space,Str "of",Space,Str "a",Space,Str "tuple",Space,Str "is",Space,Str "simply",Space,Str "the",Space,Str "concatenation",Space,Str "of",Space,Str "the",Space,Str "encodings",Space,Str "of",Space,Str "its",Space,Str "components."],Para [Str "This",Space,Str "is",Space,Str "consistent",Space,Str "with",Space,Str "the",Space,Str "view",Space,Str "that",Space,Str "a",Space,Str "tuple",Space,Str "is",Space,Str "just",Space,Str "a",Space,Str "predefined",Space,Str "data",Space,Str "type",Space,Str "with",Space,Str "a",Space,Str "single",Space,Str "constructor,",Space,Str "as",Space,Str "for",Space,Str "example:"],CodeBlock ("",["haskell"],[]) "data (,,) a b c = (,,) a b c",Para [Str "As example, given that:"],CodeBlock ("",[],[]) "\"abc\" -> [4,97,98,99,1] ",Para [Str "and:"],CodeBlock ("",[],[]) "(34::Word8) -> [34] ",Para [Str "and:"],CodeBlock ("",[],[]) "'g' -> [103] ",Para [Str "then:"],CodeBlock ("",[],[]) "(\"abc\",34,'g') -> [4,97,98,99,1,34,103] ",Para [Str "Tuples can of course be nested so:"],CodeBlock ("",[],[]) "('g',(\"abc\",(34,'g'))) -> [103,4,97,98,99,1,34,103] ",Header 2 ("",[],[]) [Str "Coding",Space,Str "of",Space,Str "Lists"],Para [Str "For",Space,Str "the",Space,Str "purpose",Space,Str "of",Space,Str "serialization,",Space,Str "a",Space,Str "list",Space,Str "is",Space,Str "considered",Space,Str "equivalent",Space,Str "to",Space,Str "the",Space,Str "data",Space,Str "type:"],CodeBlock ("",[],[]) "data List a =  L0  \n             | L1 a        (List a)\n             | L2 a a      (List a)\n             | L3 a a a    (List a)\n             | ...\n             | L65534 a .. (List a)",Para [Str "For",Space,Str "example:"],CodeBlock ("",[],[]) "([5,10,11]::[Word8]) -> [4,5,10,11,1] ",Para [Str "and:"],CodeBlock ("",[],[]) "([11,22,33]::[Word8]) -> [4,11,22,33,1] ",Para [Str "In",Space,Str "other",Space,Str "terms:",Space,Str "lists",Space,Str "are",Space,Str "represented",Space,Str "as",Space,Str "a",Space,Str "sequence",Space,Str "of",Space,Str "chunks",Space,Str "of",Space,Str "no",Space,Str "more",Space,Str "than",Space,Str "65535",Space,Str "elements",Space,Str "each",Space,Str "with",Space,Str "the",Space,Str "last",Space,Str "chunk",Space,Str "being",Space,Str "of",Space,Str "zero",Space,Str "length."],RawBlock (Format "html") "<!-- Note the presence of the hole that adds an extra constructor.-->\n",Header 2 ("coding-of-chars",[],[]) [Str "Coding",Space,Str "of",Space,Str "Chars"],Para [Str "Characters",Space,Str "are",Space,Str "encoded",Space,Str "in",Space,Str "UTF-8."],Para [Str "For",Space,Str "example:"],CodeBlock ("",[],[]) "'a' -> [97] ",Para [Str "and:"],CodeBlock ("",[],[]) "'\\32654' -> [128,231,128,190,128,142] ",Header 2 ("coding-of-numeric-types",[],[]) [Str "Coding",Space,Str "of",Space,Str "Numeric",Space,Str "Types"],Para [Str "The",Space,Str "primitive",Space,Str "numeric",Space,Str "types",Space,Str "are:"],BulletList [[Plain [Str "Fixed",Space,Str "size,",Space,Str "unsigned",Space,Str "integers:",Space,Code ("",[],[]) "Word8",Space,Str "(8",Space,Str "bits),",Space,Code ("",[],[]) "Word16",Str ",",Space,Code ("",[],[]) "Word32",Space,Str "and",Space,Code ("",[],[]) "Word64"]],[Plain [Str "Fixed",Space,Str "size,",Space,Str "signed",Space,Str "integers:",Space,Code ("",[],[]) "Int8",Str ",",Space,Code ("",[],[]) "Int16",Str ",",Space,Code ("",[],[]) "Int32",Space,Str "and",Space,Code ("",[],[]) "Int64"]],[Plain [Str "Unlimited",Space,Str "size,",Space,Str "signed",Space,Str "integers:",Space,Code ("",[],[]) "Integer"]],[Plain [Str "Fixed",Space,Str "size,",Space,Str "signed",Space,Str "floating",Space,Str "point",Space,Str "numbers:",Space,Code ("",[],[]) "Float16",Str ",",Space,Code ("",[],[]) "Float32",Space,Str "and",Space,Code ("",[],[]) "Float64"]]],Para [Str "From",Space,Str "these",Space,Str "all",Space,Str "kinds",Space,Str "of",Space,Str "numbers",Space,Str "can",Space,Str "be",Space,Str "easily",Space,Str "derived."],Para [Str "{-",Space,Str "*",Space,Str "large",Space,Str "floats",Space,Str "(rationals,",Space,Str "to",Space,Str "represent",Space,Str "precise",Space,Str "decimal",Space,Str "fractions",Space,Str "like",Space,Str "1.1)",Space,Str "-",Space,Str "how",Space,Str "to",Space,Str "represent",Space,Str "Infinity,",Space,Str "-Infinity,",Space,Str "or",Space,Str "NaN",Space,Str "?",Space,Str "(As",Space,Str "there",Space,Str "are",Space,Str "many",Space,Str "representations",Space,Str "for",Space,Str "NaN.",Space,Str "If",Space,Str "NaN",Space,Str "is",Space,Str "an",Space,Str "allowed",Space,Str "value,",Space,Str "it",Space,Str "must",Space,Str "always",Space,Str "be",Space,Str "represented",Space,Str "as",Space,Str "0xf97e00,",Space,Str "from",Space,Str "rfc7049)."],Para [Str "for",Space,Str "testing:",Space,Str "check",Space,Str "test",Space,Str "values",Space,Str "at",Space,Str "end",Space,Str "of",Space,Str "http://tools.ietf.org/html/rfc7049#section-2.3",Space,Str "-}"],RawBlock (Format "html") "<!--\nPrimitive values have no space for holes but this can be easily added by embedding the Word or Int in a data type:\n\n```haskell\ndata HoledWord64 = Holed64 Word64\n```\n-->\n",Header 3 ("coding-of-words",[],[]) [Str "Coding",Space,Str "of",Space,Str "Words"],Para [Str "All",Space,Str "unsigned",Space,Str "integers",Space,Str "(words)",Space,Str "are",Space,Str "encoded",Space,Str "as",Space,Str "varwords^[The",Space,Str "varword",Space,Str "encoding",Space,Str "is",Space,Str "a",Space,Str "variation",Space,Str "of",Space,Str "the",Space,Link [Str "varint"] ("https://developers.google.com/protocol-buffers/docs/encoding#varints",""),Space,Str "representation",Space,Str "used",Space,Str "in",Space,Str "Google's",Space,Str "Protocol",Space,Str "Buffers."],Para [Str "A",Space,Str "varint",Space,Str "is",Space,Str "a",Space,Str "sequence",Space,Str "of",Space,Str "bytes",Space,Str "where",Space,Str "every",Space,Str "byte",Space,Str "except",Space,Str "the",Space,Str "last",Space,Str "one",Space,Str "has",Space,Str "the",Space,Str "most",Space,Str "significant",Space,Str "bit",Space,Str "set",Space,Str "(the",Space,Str "msb",Space,Str "signals",Space,Str "that",Space,Str "there",Space,Str "are",Space,Str "more",Space,Str "bytes",Space,Str "in",Space,Str "the",Space,Str "sequence)."],Para [Str "Varword",Space,Str "is",Space,Str "basically",Space,Str "the",Space,Str "same",Space,Str "but",Space,Str "with",Space,Str "all",Space,Str "the",Space,Str "signalling",Space,Str "bits",Space,Str "moved",Space,Str "into",Space,Str "an",Space,Str "initial",Space,Str "prefix."],Para [Str "This",Space,Str "should",Space,Str "have",Space,Str "two",Space,Str "(small)",Space,Str "advantages:"],BulletList [[Para [Str "as",Space,Str "the",Space,Str "word",Space,Str "is",Space,Str "already",Space,Str "in",Space,Str "the",Space,Str "correct",Space,Str "sequence",Space,Str "(no",Space,Str "extraneous",Space,Str "msbs),",Space,Str "less",Space,Str "operations",Space,Str "are",Space,Str "required",Space,Str "to",Space,Str "decode",Space,Str "it"]],[Para [Str "in",Space,Str "case",Space,Str "of",Space,Str "very",Space,Str "long",Space,Str "words,",Space,Str "we",Space,Str "end",Space,Str "up",Space,Str "with",Space,Str "an",Space,Str "initial",Space,Str "prefix",Space,Str "of",Space,Str "0xFF",Space,Str "bytes",Space,Str "that",Space,Str "can",Space,Str "be",Space,Str "easily",Space,Str "compressed",Space,Str "away"]]],Para [Str "The",Space,Str "disadvantage",Space,Str "is",Space,Str "a",Space,Str "more",Space,Str "complex",Space,Str "encoder.",Space,Str "]"],Para [Str "A",Space,Str "varword",Space,Str "is",Space,Str "a",Space,Str "sequence",Space,Str "of",Space,Str "bytes",Space,Str "composed",Space,Str "by:"],BulletList [[Plain [Str "A",Space,Str "prefix",Space,Str "made",Space,Str "of:"],BulletList [[Para [Str "A",Space,Str "sequence",Space,Str "of",Space,Str "1",Space,Str "bits",Space,Str "of",Space,Str "length",Space,Str "equal",Space,Str "to",Space,Str "the",Space,Str "number",Space,Str "of",Space,Str "bytes",Space,Str "to",Space,Str "read",Space,Str "in",Space,Str "after",Space,Str "the",Space,Str "one",Space,Str "containing",Space,Str "the",Space,Str "last",Space,Str "bit",Space,Str "of",Space,Str "the",Space,Str "prefix"]],[Para [Str "A",Space,Str "0",Space,Str "bit"]]]],[Plain [Str "The",Space,Str "word",Space,Str "as:"],BulletList [[Plain [Str "Zero",Space,Str "or",Space,Str "more",Space,Str "padding",Space,Str "0",Space,Str "bits"]],[Plain [Str "The",Space,Str "significant",Space,Str "bits",Space,Str "of",Space,Str "the",Space,Str "word",Space,Str "in",Space,Str "network",Space,Str "order",Space,Str "(most",Space,Str "significant",Space,Str "bit",Space,Str "first)",Space,Str "with",Space,Str "the",Space,Str "last",Space,Str "bit",Space,Str "of",Space,Str "the",Space,Str "word",Space,Str "stored",Space,Str "in",Space,Str "the",Space,Str "lsb",Space,Str "of",Space,Str "the",Space,Str "last",Space,Str "byte",Space,Str "in",Space,Str "the",Space,Str "sequence"]]]]],Para [Str "Some",Space,Str "examples:"],Table [Str "Varword",Space,Str "Encoding",Space,Str "of",Space,Str "Unsigned",Space,Str "Integers"] [AlignDefault,AlignDefault] [0.2,0.2875] [[Plain [Str "Number"]],[Plain [Str "Encoding",Space,Str "(",Strong [Str "prefix"],Str ")"]]] [[[Para [Str "0"]],[Para [Strong [Str "0"],Str "0000000"]]],[[Para [Str "1"]],[Para [Strong [Str "0"],Str "0000001"]]],[[Para [Str "127"]],[Para [Strong [Str "0"],Str "1111111"]]],[[Para [Str "128"]],[Para [Strong [Str "10"],Str "000000",Space,Str "10000000"]]],[[Para [Str "255"]],[Para [Strong [Str "10"],Str "000000",Space,Str "11111111"]]],[[Para [Str "256"]],[Para [Strong [Str "10"],Str "000001",Space,Str "00000000"]]],[[Para [Str "16383"]],[Para [Strong [Str "10"],Str "111111",Space,Str "11111111"]]],[[Para [Str "16384"]],[Para [Strong [Str "110"],Str "00000",Space,Str "01000000",Space,Str "00000000"]]],[[Para [Str "7205759403792793"]],[Para [Str "5",Space,Str "|",Strong [Str "11111110"],Space,Str "11111111(*7)"]]],[[Para [Str "7205759403792793"]],[Para [Str "6",Space,Str "|",Space,Strong [Str "11111111",Space,Str "0"],Str "1111111",Space,Str "11111111(*7)"]]]],Para [Str "BUG:",Space,Str "there",Space,Str "is",Space,Str "no",Space,Str "valid",Space,Str "encoding",Space,Str "for"],Para [Str "72057594037927936",Space,Strong [Str "11111111",Space,Str "0"],Str "0000001",Space,Str "0(",Emph [Str "7)",Space,Str "wrong",Space,Str "as",Space,Str "there",Space,Str "are",Space,Str "7",Space,Str "after",Space,Str "prefix",Space,Strong [Str "11111110"],Space,Str "00000001",Space,Str "0("],Str "7)",Space,Str "wrong",Space,Str "as",Space,Str "there",Space,Str "are",Space,Str "8",Space,Str "after",Space,Str "prefix"],Table [Str "Coding",Space,Str "of",Space,Str "Signed",Space,Str "Integers"] [AlignDefault,AlignDefault] [0.2,0.2875] [[Plain [Str "Number"]],[Plain [Str "Encoding",Space,Str "(",Strong [Str "prefix"],Str ")"]]] [[[Para [Str "-2"]],[Para [Strong [Str "01"],Str "111110"]]],[[Para [Str "-1"]],[Para [Strong [Str "01"],Str "111111"]]],[[Para [Str "0"]],[Para [Strong [Str "00"],Str "000000"]]],[[Para [Str "1"]],[Para [Strong [Str "00"],Str "000001"]]],[[Para [Str "63"]],[Para [Strong [Str "00"],Str "111111"]]],[[Para [Str "64"]],[Para [Strong [Str "100"],Str "00000",Space,Str "01111111"]]],[[Para [Str "128"]],[Para [Strong [Str "100"],Str "00001",Space,Str "00000000"]]]],RawBlock (Format "html") "<!--\nAll integers are encoded as [Base 128 Varint](https://developers.google.com/protocol-buffers/docs/encoding#varints).\n\nA varint is a sequence of bytes, where every byte except the last one has the most significant bit (msb) set. \n\nThe number binary representation is split in groups of 7 bits, with every group being stored in the lower 7 bits of each byte, least significant group first.\n-->\n",Para [Str "The",Space,Str "encoder",Space,Str "should",Space,Str "use",Space,Str "the",Space,Str "minimum",Space,Str "sequence",Space,Str "of",Space,Str "bytes",Space,Str "necessary",Space,Str "to",Space,Str "code",Space,Str "the",Space,Str "number,",Space,Str "the",Space,Str "decoder",Space,Str "however",Space,Str "needs",Space,Str "to",Space,Str "be",Space,Str "able",Space,Str "to",Space,Str "handle",Space,Str "an",Space,Str "unlimited",Space,Str "number",Space,Str "of",Space,Str "leading",Space,Str "zeros."],Para [Str "Note",Space,Str "that",Space,Str "this",Space,Str "implies",Space,Str "that",Space,Str "equivalent",Space,Str "unsigned",Space,Str "numbers,",Space,Str "even",Space,Str "if",Space,Str "of",Space,Str "different",Space,Str "types,",Space,Str "are",Space,Str "encoded",Space,Str "in",Space,Str "the",Space,Str "same",Space,Str "way:",Space,Code ("",[],[]) "3::Word8",Space,Str "is",Space,Str "encoded",Space,Str "exactly",Space,Str "as",Space,Code ("",[],[]) "3::Word64",Space,Str "(provided",Space,Str "obviously",Space,Str "that",Space,Str "the",Space,Str "number",Space,Str "fits",Space,Str "in",Space,Str "the",Space,Str "given",Space,Str "numeric",Space,Str "type)."],Para [Str "{-",Space,Str "The",Space,Str "coding",Space,Str "is",Space,Str "optimised",Space,Str "for",Space,Str "small",Space,Str "unsigned",Space,Str "integers,",Space,Str "that",Space,Str "are",Space,Str "widely",Space,Str "used,",Space,Str "particularly",Space,Str "as",Space,Str "constructor",Space,Str "tags,",Space,Str "and",Space,Str "works",Space,Str "as",Space,Str "follows:"],BulletList [[Plain [Code ("",[],[]) "Word",Str "s",Space,Str "have",Space,Str "variable",Space,Str "length",Space,Str "representations"]],[Plain [Str "In",Space,Str "the",Space,Str "first",Space,Str "byte",Space,Str "in",Space,Str "the",Space,Str "sequence:"],BulletList [[Plain [Str "the",Space,Str "values",Space,Str "between",Space,Code ("",[],[]) "0 and 256 minus the Word length in bytes",Space,Str "are",Space,Str "used",Space,Str "to",Space,Str "code",Space,Str "the",Space,Str "corresponding",Space,Str "integer"]],[Plain [Str "the",Space,Str "other",Space,Str "values",Space,Str "indicate",Space,Str "the",Space,Str "number",Space,Str "of",Space,Str "bytes",Space,Str "that",Space,Str "follow",Space,Str "where",Space,Code ("",[],[]) "number of bytes = 257 - value"]]]],[Plain [Code ("",[],[]) "Word",Str "s",Space,Str "(unsigned",Space,Str "integers)",Space,Str "are",Space,Str "written",Space,Str "in",Space,Str "big-endian",Space,Str "(network)",Space,Str "order."]]],Para [Str "Major",Space,Str "types",Space,Str "0",Space,Str "and",Space,Str "1",Space,Str "are",Space,Str "designed",Space,Str "in",Space,Str "such",Space,Str "a",Space,Str "way",Space,Str "that",Space,Str "they",Space,Str "can",Space,Str "be",Space,Str "encoded",Space,Str "in",Space,Str "C",Space,Str "from",Space,Str "a",Space,Str "signed",Space,Str "integer",Space,Str "without",Space,Str "actually",Space,Str "doing",Space,Str "an",Space,Str "if-then-",Space,Str "else",Space,Str "for",Space,Str "positive/negative",Space,Str "(Figure",Space,Str "2).",Space,Str "This",Space,Str "uses",Space,Str "the",Space,Str "fact",Space,Str "that",Space,Str "(-1-n),",Space,Str "the",Space,Str "transformation",Space,Str "for",Space,Str "major",Space,Str "type",Space,Str "1,",Space,Str "is",Space,Str "the",Space,Str "same",Space,Str "as",Space,Str "~n",Space,Str "(bitwise",Space,Str "complement)",Space,Str "in",Space,Str "C",Space,Str "unsigned",Space,Str "arithmetic;",Space,Str "~n",Space,Str "can",Space,Str "then",Space,Str "be",Space,Str "expressed",Space,Str "as",Space,Str "(-1)^n",Space,Str "for",Space,Str "the",Space,Str "negative",Space,Str "case,",Space,Str "while",Space,Str "0^n",Space,Str "leaves",Space,Str "n",Space,Str "unchanged",Space,Str "for",Space,Str "non-negative.",Space,Str "The",Space,Str "sign",Space,Str "of",Space,Str "a",Space,Str "number",Space,Str "can",Space,Str "be",Space,Str "converted",Space,Str "to",Space,Str "-1",Space,Str "for",Space,Str "negative",Space,Str "and",Space,Str "0",Space,Str "for",Space,Str "non-negative",Space,Str "(0",Space,Str "or",Space,Str "positive)",Space,Str "by",Space,Str "arithmetic-",Space,Str "shifting",Space,Str "the",Space,Str "number",Space,Str "by",Space,Str "one",Space,Str "bit",Space,Str "less",Space,Str "than",Space,Str "the",Space,Str "bit",Space,Str "length",Space,Str "of",Space,Str "the",Space,Str "number",Space,Str "(for",Space,Str "example,",Space,Str "by",Space,Str "63",Space,Str "for",Space,Str "64-bit",Space,Str "numbers)."],Para [Str "void",Space,Str "encode_sint(int64_t",Space,Str "n)",Space,Str "{",Space,Str "uint64t",Space,Str "ui",Space,Str "=",Space,Str "n",Space,Str ">>",Space,Str "63;",Space,Str "//",Space,Str "extend",Space,Str "sign",Space,Str "to",Space,Str "whole",Space,Str "length",Space,Str "mt",Space,Str "=",Space,Str "ui",Space,Str "&",Space,Str "0x20;",Space,Str "//",Space,Str "extract",Space,Str "major",Space,Str "type",Space,Str "ui",Space,Str "^=",Space,Str "n;",Space,Str "//",Space,Str "complement",Space,Str "negatives",Space,Str "if",Space,Str "(ui",Space,Str "<",Space,Str "24)",Space,Emph [Str "p++",Space,Str "=",Space,Str "mt",Space,Str "+",Space,Str "ui;",Space,Str "else",Space,Str "if",Space,Str "(ui",Space,Str "<",Space,Str "256)",Space,Str "{",Space],Str "p++",Space,Str "=",Space,Str "mt",Space,Str "+",Space,Str "24;",Space,Str "*p++",Space,Str "=",Space,Str "ui;",Space,Str "}",Space,Str "else"],Para [Str "0..127==2^7-1",Space,Str "0XXXXXXX",Space,Str "128..16383",Space,Str "10XXXXXX",Space,Str "XXXXXXXX",Space,Str "16384..",Space,Str "110XXXXX",Space,Str "XXXXXXXX",Space,Str "XXXXXXXX",Space,Str "XXXXXXXX"],Para [Str "Start",Space,Str "with",Space,Str "a",Space,Str "compact",Space,Str "count",Space,Str "of",Space,Str "bytes",Space,Str "followed",Space,Str "by",Space,Str "the",Space,Str "actual",Space,Str "complement-2",Space,Str "number.",Space,Str "This",Space,Str "can",Space,Str "be",Space,Str "implemented",Space,Str "efficiently",Space,Str "as",Space,Str "a",Space,Str "jump",Space,Str "table?",Space,Str "No,",Space,Str "it",Space,Str "requires",Space,Str "a",Space,Str "number",Space,Str "of",Space,Str "left",Space,Str "shifts."],Para [Str "Count:",Space,Str "Prefix",Space,Str "|",Space,Str "Num",Space,Str "Bytes",Space,Str "Overhead",Space,Str "0",Space,Str "1",Space,Str "1/7",Space,Str "1.00",Space,Str "2",Space,Str "3/16",Space,Str "1.01",Space,Str "3",Space,Str "3/24",Space,Str "1.10",Space,Str "4",Space,Str "3/32",Space,Str "111.000",Space,Str "5",LineBreak,Str "111.001",Space,Str "6",Space,Str "111.010",Space,Str "7",Space,Str "111.011",Space,Str "8",Space,Str "111.100",Space,Str "9",Space,Str "111.110",Space,Str "10",Space,Str "111.111.0000",Space,Str "11",Space,Str "..."],Para [Str "The",Space,Str "encoding",Space,Str "is",Space,Str "composed",Space,Str "by:"],Para [Str "A",Space,Str "Prefix",Space,Str "composed",Space,Str "by:",Space,Str "*",Space,Str "0",Space,Str "if",Space,Str "the",Space,Str "last",Space,Str "byte",Space,Str "of",Space,Str "the",Space,Str "prefix",Space,Str "also",Space,Str "contains",Space,Str "the",Space,Str "first",Space,Str "byte",Space,Str "of",Space,Str "the",Space,Str "number",Space,Str "|",Space,Str "1",Space,Str "otherwise",Space,Str "*",Space,Str "(num",Space,Str "of",Space,Str "bytes",Space,Str "used",Space,Str "by",Space,Str "number-1)",Space,Str "1s",Space,Str "*",Space,Str "0"],Para [Str "The",Space,Str "number",Space,Str "in",Space,Str "network",Space,Str "order,",Space,Str "with",Space,Str "the",Space,Str "first",Space,Str "byte,",Space,Str "if",Space,Str "indicated,",Space,Str "stored",Space,Str "in",Space,Str "the",Space,Str "last",Space,Str "byte",Space,Str "of",Space,Str "the",Space,Str "prefix."],Para [Str "0",Space,Str "00.000000",Space,Str "1",Space,Str "00.000001",Space,Str "63",Space,Str "00.111111",Space,Str "64",Space,Str "110.00000",Space,Str "01000000",Space,Str "..",Space,Str "127",Space,Str "110.00000",Space,Str "11111111",Space,Str "128",Space,Str "010.00001",Space,Str "00000000",Space,Str "4095",Space,Str "010.11111",Space,Str "00000000"],Para [Str "-128",Space,Str "0.100000",Space,Str "-3",Space,Str "0.1111100",Space,Str "-2",Space,Str "0.1111101",Space,Str "-1",Space,Str "0.1111111"],Para [Str "Plus:",Space,Str "Or:",Space,Str "The",Space,Str "number",Space,Str "is",Space,Str "already",Space,Str "in",Space,Str "correct",Space,Str "network",Space,Str "order",Space,Str "(8086/ARM",Space,Str "is",Space,Str "however",Space,Str "LE",Space,Str "order),",Space,Str "no",Space,Str "shifts",Space,Str "required",Space,Str "(but",Space,Str "negative",Space,Str "numbers",Space,Str "need",Space,Str "to",Space,Str "have",Space,Str "their",Space,Str "sign",Space,Str "extended)."],Para [Str "Minus:",Space,Str "An",Space,Str "additional",Space,Str "bit",Space,Str "lost."],Para [Str "The",Space,Str "encoding",Space,Str "is",Space,Str "composed",Space,Str "by:"],Para [Str "A",Space,Str "Prefix",Space,Str "composed",Space,Str "by:",Space,Str "*",Space,Str "(num",Space,Str "of",Space,Str "bytes",Space,Str "used",Space,Str "by",Space,Str "number-1)",Space,Str "1s",Space,Str "if",Space,Str "the",Space,Str "number",Space,Str "is",Space,Str ">0",Space,Str "|0s",Space,Str "otherwise",Space,Str "*",Space,Str "A",Space,Str "number",Space,Str "of",Space,Str "0s",Space,Str "if",Space,Str "the",Space,Str "number",Space,Str "is",Space,Str ">0",Space,Str "|1s",Space,Str "otherwise",Space,Str "to",Space,Str "fill",Space,Str "the",Space,Str "space",Space,Str "up",Space,Str "to",Space,Str "the",Space,Str "beginning",Space,Str "of",Space,Str "the",Space,Str "number"],BulletList [[Plain [Str "The",Space,Str "number",Space,Str "in",Space,Str "network",Space,Str "order,",Space,Str "with",Space,Str "the",Space,Str "first",Space,Str "byte,",Space,Str "if",Space,Str "it",Space,Str "fits,",Space,Str "stored",Space,Str "in",Space,Str "the",Space,Str "last",Space,Str "byte",Space,Str "of",Space,Str "the",Space,Str "prefix."]]],Para [Str "-2",Space,Str "1111111.0",Space,Str "-1",Space,Str "11111111.",Space,Str "0",Space,Str "00000000.",Space,Str "1",Space,Str "0000000.1",Space,Str "127",Space,Str "0.1111111",Space,Str "128",Space,Str "1000000.1",Space,Str "00000000"],Para [Str "00000000",Space,Str "1",Space,Str "1/8",Space,Str "1.0",Space,Str "2",Space,Str "1/8",Space,Str "11.0",Space,Str "3",Space,Str "1/8",Space,Str "111.0",Space,Str "4",Space,Str "1/8",LineBreak,Str "1111.0",Space,Str "5",Space,Str "1/8",Space,Str "11111.0",Space,Str "6",Space,Str "1/8",Space,Str "111111.0",Space,Str "7",Space,Str "1/8",Space,Str "11111110",Space,Str "8",Space,Str "1/8",Space,Str "11111111",Space,Str "9",Space,Str "1/8"],Para [Str "This",Space,Str "also",Space,Str "makes",Space,Str "for",Space,Str "a",Space,Str "nice",Space,Str "jump",Space,Str "table.",Space,Str "And",Space,Str "it",Space,Str "should",Space,Str "be",Space,Str "really",Space,Str "easy",Space,Str "to",Space,Str "compress",Space,Str "sequences",Space,Str "of",Space,Str "1111111s",Space,Str "so",Space,Str "it",Space,Str "also",Space,Str "works",Space,Str "for",Space,Str "really",Space,Str "long",Space,Str "numbers",Space,Str "so",Space,Str "the",Space,Str "real",Space,Str "overhead",Space,Str "is",Space,Str "almost",Space,Str "nothing."],Para [Str "Another",Space,Str "alternative:",Space,Str "Always",Space,Str "optimise",Space,Str "for",Space,Str "the",Space,Str "specific",Space,Str "type,",Space,Str "so",Space,Str "Word8",Space,Str "is",Space,Str "just",Space,Str "a",Space,Str "Word8,",Space,Str "Word16",Space,Str "is",Space,Str "..",Space,Str "a",Space,Str "varint."],Para [Str "As",Space,Str "soon",Space,Str "as",Space,Str "we",Space,Str "know",Space,Str "the",Space,Str "number",Space,Str "of",Space,Str "bytes",Space,Str "we",Space,Str "can",Space,Str "just",Space,Str "copy",Space,Str "them",Space,Str "over",Space,Str "and",Space,Str "mask",Space,Str "them",Space,Str "to",Space,Str "remove",Space,Str "the",Space,Str "prefix."],Para [Str "Or",Space,Str "recursive",Space,Str "numbytes",Space,Str "we",Space,Str "calculate",Space,Str "how",Space,Str "many",Space,Str "bits",Space,Str "are",Space,Str "required",Space,Str "to",Space,Str "code",Space,Str "the",Space,Str "number.",Space,Str "we",Space,Str "write",Space,Str "this",Space,Str "as:",Space,Str "num_bits",Space,Str "++",Space,Str "num",Space,Str "if",Space,Str "num_bits",Space,Str "is",Space,Str "<=2",Space,Str "recursively",Space,Str "written"],Para [Str "The",Space,Str "first",Space,Str "two",Space,Str "bits",Space,Str "mean:",Space,Str "00",Space,Str "=",Space,Str "6",Space,Str "bits",Space,Str "01",Space,Str "=",Space,Str "8+6",Space,Str "bits",Space,Str "10",Space,Str "=",Space,Str "2",Emph [Str "8+6",Space,Str "bits",Space,Str "11",Space,Str "=",Space,Str "read",Space,Str "next",Space,Str "4",Space,Str "bits",Space,Str "as",Space,Str "number",Space,Str "of",Space,Str "bits",Space,Str "11.0000",Space,Str "=",Space,Str "3"]],Para [Str "Or",Space,Str "equivalently",Space,Str "MSB",Space,Str "encoding:",Space,Str "higher",Space,Str "bit",Space,Str "is",Space,Str "used",Space,Str "as",Space,Str "has-next-byte",Space,Str "flag.",Space,Str "-}"],Header 3 ("coding-of-signed-integers",[],[]) [Str "Coding",Space,Str "of",Space,Str "Signed",Space,Str "Integers"],Para [Str "All",Space,Str "signed",Space,Str "integers,",Space,Str "including",Space,Str "infinite",Space,Str "precision",Space,Code ("",[],[]) "Integer",Str "s,",Space,Str "are",Space,Str "converted",Space,Str "to",Space,Str "unsigned",Space,Str "integers",Space,Str "using",Space,Link [Str "Zig-Zag",Space,Str "encoding"] ("https://developers.google.com/protocol-buffers/docs/encoding#types",""),Space,Str "and",Space,Str "then",Space,Str "coded."],Para [Str "<--",Space,Str "*",Space,Str "http://tools.ietf.org/html/rfc7049",Space,Str "*",Space,Str "prefix",Space,Str "with",Space,Str "sign",Space,Str "bit",Space,Str "--",Space,Str "one",Space,Str "extra",Space,Str "byte",Space,Str "per",Space,Str "integers",Space,Str "++",Space,Str "(ok",Space,Str "for",Space,Str "infinite",Space,Str "ints)",Space,Str "unsigned",Space,Str "starting",Space,Str "with",Space,Str "zero",Space,Str "-1",Space,Str "minus",Space,Str "the",Space,Str "encoded",Space,Str "unsigned",Space,Str "integer.",Space,Str "For",Space,Str "example,",Space,Str "the",Space,Str "integer",Space,Str "-500",Space,Str "would",Space,Str "be",Space,Str "0b001_11001",Space,Str "(major",Space,Str "type",Space,Str "1,",Space,Str "additional",Space,Str "information",Space,Str "25)",Space,Str "followed",Space,Str "by",Space,Str "the",Space,Str "two",Space,Str "bytes",Space,Str "0x01f3,",Space,Str "which",Space,Str "is",Space,Str "499",Space,Str "in",Space,Str "decimal",Space,Str "*",Space,Str "map",Space,Str "-max..+max",Space,Str "to",Space,Str "0..2*max",Space,Str "by",Space,Str "adding",Space,Str "max:",Space,Str "http://en.wikipedia.org/wiki/Offset-binary",Space,Str "--",Space,Str "not",Space,Str "ok",Space,Str "for",Space,Str "infinite",Space,Str "ints"],Para [Code ("",[],[]) "Int",Str "s",Space,Str "are",Space,Str "converted",Space,Str "to",Space,Str "their",Space,Str "equivalent",Space,Str "two's",Space,Str "complement",Space,Code ("",[],[]) "Word",Space,Str "and",Space,Str "then",Space,Str "coded.",Space,Str "-->"],Para [Str "For",Space,Str "example:"],CodeBlock ("",[],[]) "(-1::Int8) -> [1] ",CodeBlock ("",[],[]) "(3::Int8) -> [6] ",CodeBlock ("",[],[]) "(-2::Int16) -> [3] ",CodeBlock ("",[],[]) "(5::Int16) -> [10] ",CodeBlock ("",[],[]) "(-5::Int32) -> [9] ",CodeBlock ("",[],[]) "(11::Int32) -> [22] ",CodeBlock ("",[],[]) "(-17283923::Int64) -> [226,15,118,165] ",CodeBlock ("",[],[]) "(1567823::Int64) -> [224,47,216,158] ",CodeBlock ("",[],[]) "(-2::Integer) -> [3] ",CodeBlock ("",[],[]) "(5::Integer) -> [10] ",CodeBlock ("",[],[]) "(-17283923::Integer) -> [226,15,118,165] ",CodeBlock ("",[],[]) "(1567823::Integer) -> [224,47,216,158] ",CodeBlock ("",[],[]) "(829374657329284628329102323297256347::Integer) -> [255,255,1,63,118,167,198,59,48,174,174,200,20,180,93,103,7,54] ",RawBlock (Format "html") "<!--\n### Coding of Integers\n\nIntegers are coded as if they were defined as follows:\n\n```haskell\ndata Integer = Integer Sign LongWord\n\ndata Sign = Positive | Negative\n```\n\nWhere LongWord is a 255 bytes long Word, coded according to the general Word serialisation scheme previously illustrated.\n\nThis supports the coding of integers with up to 611 decimal digits.\n-->\n",Header 3 ("coding-of-floats",[],[]) [Str "Coding",Space,Str "of",Space,Str "Floats"],Para [Link [Str "Float16"] ("http://en.wikipedia.org/wiki/Half-precision_floating-point_format",""),Str ",",Space,Link [Str "Float32"] ("http://en.wikipedia.org/wiki/Binary32",""),Space,Str "and",Space,Link [Str "Float64"] ("http://en.wikipedia.org/wiki/Binary64",""),Space,Str "numbers",Space,Str "are",Space,Str "coded",Space,Str "as",Space,Str "standard",Space,Str "big",Space,Str "endian",Space,Str "IEEE754",Space,Str "floats."],Header 3 ("coding-of-large-and-precise-floats",[],[]) [Str "Coding",Space,Str "of",Space,Str "Large",Space,Str "and",Space,Str "Precise",Space,Str "Floats"],Para [Str "When",Space,Str "Float64",Space,Str "precision",Space,Str "is",Space,Str "not",Space,Str "enough",Space,Str "or",Space,Str "when",Space,Str "there",Space,Str "is",Space,Str "a",Space,Str "need",Space,Str "of",Space,Str "preserving",Space,Str "decimal",Space,Str "fractions",Space,Str "such",Space,Str "as",Space,Str "1.1",Space,Str "that",Space,Str "cannot",Space,Str "be",Space,Str "represented",Space,Str "exactly",Space,Str "in",Space,Str "binary",Space,Str "floating",Space,Str "point",Space,Str "the",Space,Code ("",[],[]) "Rational",Space,Str "data",Space,Str "type",Space,Str "should",Space,Str "be",Space,Str "used:"],CodeBlock ("",["haskell"],[]) "module Math where\n\nimport Math.Integer\n\ndata Rational = Rational\n                Integer -- Numerator\n                Integer -- Denominator",Para [Str "Example:",Space,Code ("",[],[]) "1.1",Space,Str "is",Space,Str "expressed",Space,Str "as",Space,Code ("",[],[]) "Rational 11 10",Str "."]]